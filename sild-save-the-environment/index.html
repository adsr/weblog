<!DOCTYPE html>
<html lang="en-us">

    <head>
    <title>Sild; save the environment</title>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="icon" href="/images/jeff.ico" type="image/x-icon" />
    <link rel="stylesheet" href="/css/style.css">
    <link href="" rel="alternate feed" type="application/rss+xml" title="RSS Feed for blog.jfo.click" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>


    <body>
        <div id="content">
            <header class="site-header">
    <a href="https://blog.jfo.click/">archive</a> &mdash;
    <a href="https://blog.jfo.click/about">about</a> &mdash;
    <a href="https://blog.jfo.click/feed.xml">rss</a>
</header>

            <article>
                <p>
                    <h1>Sild; save the environment</h1>
                    <sub>July 16, 2016 </sub>
                <p>
                <div>
                    

<p>A lot of refactoring, and makefiling, and shuffling things around in the last
few posts, but I&rsquo;m to a point where I feel comfortable moving on!</p>

<p>The next basic function in the pipe is <code>define</code>; it is going to take two
arguments, and look something like this:</p>

<pre><code>(define whatever (quote (1 2 3)))
</code></pre>

<p>where <code>whatever</code> is any arbitrary <code>LABEL</code> and the second argument is
anything at all. <code>define</code> will evaluate the second argument and store it in
some environment under the label given as the first argument, and after this,
all references in the code to the label <code>whatever</code> should be evaluated to the
second argument. So, for instance:</p>

<pre><code>(cons (quote 0) whatever)
</code></pre>

<p>Should evaluate <code>(quote 0)</code> to <code>0</code> and <code>whatever</code> to <code>(1 2 3)</code>, and then cons
them together to return:</p>

<pre><code>(0 1 2 3)
</code></pre>

<p>I know that in order to save that association, I&rsquo;m going to need a place to
store it, and for that, I&rsquo;ll need some concept of an &lsquo;environment&rsquo;. I don&rsquo;t
really know what it&rsquo;s going to look like yet, but I know it&rsquo;s going to need a
header file, and I have a general idea of what its interface is going to be.  I
know I&rsquo;m going to have some sort of struct called an Env, I know I&rsquo;m going to
need a setter function that takes an <code>Env</code> and a key value pair and returns
void, and a getter that takes an <code>Env</code> and a key and returns a value- and I
know I&rsquo;ll need a deletion function too, or at least a way to free a whole env
up at once. This is basically a miniature little CRUD interface!  (set =
Create, get = Read, delete+set = Update, delete = Delete)</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cp">#ifndef ENV_GUARD</span>
<span class="cp">#define ENV_GUARD</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_Env</span> <span class="n">Env</span><span class="p">;</span>

<span class="n">C</span> <span class="o">*</span><span class="nf">set</span><span class="p">(</span><span class="n">Env</span><span class="o">*</span><span class="p">,</span><span class="n">C</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">C</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
<span class="n">C</span> <span class="o">*</span><span class="nf">get</span><span class="p">(</span><span class="n">Env</span><span class="o">*</span><span class="p">,</span> <span class="n">C</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
<span class="n">C</span> <span class="o">*</span><span class="nf">delete</span><span class="p">(</span><span class="n">Env</span><span class="o">*</span><span class="p">,</span> <span class="n">C</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>

<span class="cp">#endif</span>
</code></pre></div>

<p>I&rsquo;ll jump a little bit now, before implementing something for this, to where it
will be used in the evaluation code! <code>eval</code> currently looks like this:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">eval</span><span class="p">(</span><span class="n">C</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">LIST</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="n">C</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">apply</span><span class="p">(</span><span class="n">eval</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">list</span><span class="p">));</span>
            <span class="n">out</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">LABEL</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">BUILTIN</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">NIL</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Where evaluating a <code>LABEL</code> simply returns itself. This is silly- I want a label
to return what it has been assigned to, or else throw an error! This is where I
will be <code>get()</code>ting a value from an <code>Env</code></p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cp">#include</span> <span class="cpf">&quot;eval.h&quot;</span><span class="cp"></span>

<span class="n">C</span> <span class="o">*</span><span class="nf">eval</span><span class="p">(</span><span class="n">C</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">LIST</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="n">C</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">apply</span><span class="p">(</span><span class="n">eval</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">list</span><span class="p">));</span>
            <span class="n">out</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">LABEL</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">get</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
        <span class="k">case</span> <span class="nl">BUILTIN</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">NIL</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Immediately we see a big problem with this- there is no <code>Env</code> to pass through
to this getter function! I haven&rsquo;t added that bit yet! And sure enough:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">src</span><span class="o">/</span><span class="n">eval</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">37</span><span class="o">:</span><span class="mi">24</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="n">use</span> <span class="n">of</span> <span class="n">undeclared</span> <span class="n">identifier</span> <span class="err">&#39;</span><span class="n">env</span><span class="err">&#39;</span>
    <span class="k">return</span> <span class="n">get</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
           <span class="o">^</span>
</code></pre></div>

<p>Get ready for a big, but boring changeset. In order to have access to that
Environment (whatever it turns out to be!) in all of these calls to <code>eval</code> and
all the builtin functions, I have to add an <code>Env</code> parameter to <em>every single
function signature</em> and pass it through to every single call to eval.  I&rsquo;m not
going to show that, but you can see it
<a href="https://github.com/urthbound/sildpost/commit/38483fea3045683f5ddd0525f24bdb4d444cdca9">here</a></p>

<p>One operative part is creating a NULL <code>Env</code> in <code>evalfile</code> and passing it
through into <code>eval</code>:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="n">Env</span> <span class="o">*</span> <span class="n">env</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">while</span><span class="p">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
        <span class="n">print</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="n">free_cell</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>

<p>and that I&rsquo;ve set the <code>get()</code> function to simply return an empty list for <em>any</em> label.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">get</span><span class="p">(</span><span class="n">Env</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">C</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">empty_list</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p>Since <code>get</code> inside of <code>eval</code> is just returning an empty list, I can eval something like this:</p>
<div class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span></span><span class="p">(</span><span class="nb">cons </span><span class="nv">something</span> <span class="nv">somethingelse</span><span class="p">)</span>
</code></pre></div>

<p>And it will evaluate both of those labels to an empty list and return:</p>
<div class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span></span><span class="p">(())</span>
</code></pre></div>

<p>Ah, I should remember to clean up the label cell that I fetched!</p>

<pre><code>C *eval(C* c, Env *env) {
    switch (c-&gt;type) {
        case LIST:
        {
            C *out = apply(eval(c-&gt;val.list, env), env);
            out-&gt;next = c-&gt;next;
            free(c);
            return out;
        }
        case LABEL:
        {
            C *out = get(env, c);
            free_one_cell(c);
            return out;
        }
        case BUILTIN:
        case NIL:
            return c;
    }
}
</code></pre>

<hr>

<p><code>Env</code> has been typedeffed, so I can pass pointers to it around, but I haven&rsquo;t
defined what an <code>Env</code> is, yet. Let&rsquo;s start with this:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">struct</span> <span class="n">Env</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
    <span class="n">C</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Which is super reductive, but will illustrate a point! Now, I&rsquo;ll set <code>get</code> to
return <code>truth</code> if the key passed in matches the key in the env, and the empty
list otherwise:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">get</span><span class="p">(</span><span class="n">Env</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">C</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">scmp</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">truth</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">empty_list</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Back in the <code>eval_file</code> function, I&rsquo;m going to have to actually pass in a real
live <code>Env</code> now, instead of just a NULL pointer, since I will be dereferencing
it. BUT, I can&rsquo;t assign values to the <code>Env</code> from there, since I haven&rsquo;t made
the internals public (for good reasons!). I&rsquo;ll introduce a <code>new_env()</code> function
to <code>env.c</code> and <code>env.h</code> that will return a pointer to an env, and I&rsquo;ll set a key
for it!</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">Env</span> <span class="o">*</span><span class="nf">new_env</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Env</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Env</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">};</span>
    <span class="n">out</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="s">&quot;derp&quot;</span><span class="p">;</span>
    <span class="n">out</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Looks a lot like <code>makecell</code>, doesn&rsquo;t it?</p>

<p>This Env only has one key: &lsquo;derp&rsquo;. When <code>get</code> tries to evaluate LABELS, it will
return truth for only labels with the label <code>derp</code> and empty lists for
everything else.</p>

<p>Back in eval_file:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">void</span> <span class="nf">eval_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error opening file: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
        <span class="n">exit</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">C</span> <span class="o">*</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">Env</span> <span class="o">*</span><span class="n">env</span> <span class="o">=</span> <span class="n">new_env</span><span class="p">();</span>

    <span class="k">while</span><span class="p">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
        <span class="n">print</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="n">free_cell</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Now, if I evaluate something like this:</p>

<pre><code>(cons something somethingelse)
(cons derp somethingelse)
</code></pre>

<p>I get back:</p>

<pre><code>(())
(#t)
</code></pre>

<p>Which is exactly what I wanted to happen!</p>

<p>If I:</p>

<pre><code>(cons somethingelse derp)
</code></pre>

<p>I&rsquo;ll get an error, which makes sense, since that evaluates to</p>

<pre><code>(cons () #t)
</code></pre>

<p>Which shouldn&rsquo;t work, since I can&rsquo;t cons something <em>onto</em> something that isn&rsquo;t
a list.</p>

<hr>

<p>Ok, so, this is pretty contrived. I really need a way to <code>set</code> values in an
Env, and to search through the entries to try and find a match. First of all,
that struct definition of Env is completely useless for this, as it only holds
one key value pair. That&rsquo;s really an <code>Entry</code>, which I will define internally
above <code>Env</code></p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Entry</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
    <span class="n">C</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Entry</span><span class="p">;</span>
</code></pre></div>

<p>Env, now, should just hold a single thing: a pointer to the first entry in a
dictionary!</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">struct</span> <span class="n">Env</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Entry</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Now, I can change what was <code>new_env</code> to <code>new_entry</code> and add a new <code>new_env</code>:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">static</span> <span class="n">Entry</span> <span class="o">*</span><span class="nf">new_entry</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Entry</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Entry</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">};</span>
    <span class="n">out</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="s">&quot;derp&quot;</span><span class="p">;</span>
    <span class="n">out</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Env</span> <span class="o">*</span><span class="nf">new_env</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Env</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Env</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">};</span>
    <span class="n">out</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">new_entry</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>This works!</p>

<pre><code>(())
(#t)
</code></pre>

<p>Now, as I&rsquo;m passing around Env pointers outside of this file, I&rsquo;m really
passing around a pointer to a pointer of the first entry in a list of entries!
Just like I did in the first few posts defining cells, I&rsquo;m going to use a
singly linked list structure to define these Entrys. That means they need to
have a reference to the next cell in the series:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Entry</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
    <span class="n">C</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Entry</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Entry</span><span class="p">;</span>
</code></pre></div>

<p>Let&rsquo;s make two entries!</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">static</span> <span class="n">Entry</span> <span class="o">*</span><span class="nf">new_entry</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Entry</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Entry</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">};</span>
    <span class="n">out</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="s">&quot;derp&quot;</span><span class="p">;</span>
    <span class="n">out</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">out</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">Entry</span> <span class="o">*</span><span class="nf">new_entry2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Entry</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Entry</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">};</span>
    <span class="n">out</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="s">&quot;another&quot;</span><span class="p">;</span>
    <span class="n">out</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">out</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_entry</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Env</span> <span class="o">*</span><span class="nf">new_env</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Env</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Env</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">};</span>
    <span class="n">out</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">new_entry2</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Boy, that&rsquo;s ugly! Now, the Env looks like this:</p>

<pre><code>Env
  \
   Entry[another] -&gt; Entry[derp] -&gt; NULL
</code></pre>

<p>I need to adjust the get function to traverse this list, and to know how to
handle a NULL pointer.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">get</span><span class="p">(</span><span class="n">Env</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">C</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Entry</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">scmp</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">truth</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">empty_list</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p>I&rsquo;m going to skip the sentinel node this time, because I&rsquo;m only implementing
that method that looks through everything, and I can keep that as is!</p>

<p>Now, both <code>&quot;derp&quot;</code> and <code>&quot;another&quot;</code> will return <code>#t</code>, and still everything else
will return an empty list.</p>

<pre><code>(cons another somethingelse)
(cons derp literallyanything)
</code></pre>

<p>Will yield;</p>

<pre><code>(#t)
(#t)
</code></pre>

<p>This is getting interesting, eh?</p>

<hr>

<p>Let&rsquo;s look back at those <code>new_entry</code> functions. I can totally generalize that!</p>

<pre><code>static Entry *new_entry(char *key, C *value) {
    char *keyval = malloc(sizeof(key));
    if (!keyval) { exit(1); };
    strcpy(keyval, key);

    Entry *out = malloc(sizeof(Entry));
    if (!out) { exit(1); };

    out-&gt;key = keyval;
    out-&gt;value = value;
    out-&gt;next = NULL;
    return out;
}
</code></pre>

<p>Now, I can make those entries using this function inside of <code>new_env</code> itself.</p>

<pre><code>Env *new_env() {

    struct Entry *entry1 = new_entry(&quot;one&quot;, NULL);
    struct Entry *entry2 = new_entry(&quot;two&quot;, NULL);
    entry1-&gt;next = entry2;

    Env *out = malloc(sizeof(Env));
    if (!out) { exit(1); };
    out-&gt;head = entry1;
    return out;
}
</code></pre>

<p>And I get the same effect!</p>

<hr>

<p>We&rsquo;re getting close, now! Back in the <code>get</code> function, I&rsquo;m just returning true
if I find a match, but what I really want is arbitrary values being assigned
and returned.</p>
<div class="highlight"><pre><code class="language-diff" data-lang="diff"><span></span> C *get(Env* env, C *key) {
     Entry *cur = env-&gt;head;
     while (cur) {
         if (scmp(key-&gt;val.label, cur-&gt;key)) {
<span class="gd">-            return truth();</span>
<span class="gi">+            return cur-&gt;value;</span>
         }
         cur = cur-&gt;next;
     }
     return NULL;
 }
</code></pre></div>

<p>and down in <code>new_env()</code>:</p>
<div class="highlight"><pre><code class="language-diff" data-lang="diff"><span></span> Env *new_env() {

<span class="gd">-    struct Entry *entry1 = new_entry(&quot;one&quot;, NULL);</span>
<span class="gd">-    struct Entry *entry2 = new_entry(&quot;two&quot;, NULL);</span>
<span class="gi">+    struct Entry *entry1 = new_entry(&quot;one&quot;, truth());</span>
<span class="gi">+    struct Entry *entry2 = new_entry(&quot;two&quot;, truth());</span>
     entry1-&gt;next = entry2;

     Env *out = malloc(sizeof(Env));
     if (!out) { exit(1); };
     out-&gt;head = entry1;
     return out;
 }
</code></pre></div>

<p>This works great for something like:</p>

<pre><code>one
two
anything
</code></pre>

<p>which yields:</p>

<pre><code>#t
#t

Error: unbound label: anything

shell returned 1
</code></pre>

<p>Just as we want, but what about this?</p>

<pre><code>one
one
</code></pre>

<p>Can you guess? When <code>eval</code> looks at the first <code>one</code>, it retrieves the cell
pointer to the <code>Entry</code>&rsquo;s <code>value</code> member. Remember that eval as I&rsquo;ve written it
always cleans up after itself:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span>        <span class="k">case</span> <span class="nl">LABEL</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="n">C</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">free_one_cell</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="c1">// right here!</span>
                <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</code></pre></div>

<p>Which means that the second time I try to evaluate <code>one</code>, it tries to clean up after itself and blows up, because that pointer has already been freed:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">sild</span><span class="p">(</span><span class="mi">76627</span><span class="p">,</span><span class="mh">0x7fff7b607000</span><span class="p">)</span> <span class="nl">malloc</span><span class="p">:</span> <span class="o">***</span> <span class="n">error</span> <span class="k">for</span> <span class="n">object</span> <span class="mh">0x7f88f0403380</span><span class="o">:</span> <span class="n">pointer</span> <span class="n">being</span> <span class="n">freed</span> <span class="n">was</span> <span class="n">not</span> <span class="n">allocated</span>
<span class="o">***</span> <span class="n">set</span> <span class="n">a</span> <span class="n">breakpoint</span> <span class="n">in</span> <span class="n">malloc_error_break</span> <span class="n">to</span> <span class="n">debug</span>

<span class="n">Command</span> <span class="n">terminated</span>
</code></pre></div>

<p>When I fetch a value from the Environment, I need to be fetching a <em>copy</em> of
it, so that when it passes through the rest of the evaluation, and gets cleaned
up afterwards, the original entry is still intact and can be fetched again.</p>

<p>this function will live back in <code>cell.c</code>, and will look exactly like
<code>free_cell</code> and <code>free_one_cell</code>, which look like this:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">void</span> <span class="nf">free_cell</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">LABEL</span><span class="p">:</span>
            <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">);</span>
            <span class="n">free_cell</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">LIST</span><span class="p">:</span>
            <span class="n">free_cell</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
            <span class="n">free_cell</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">BUILTIN</span><span class="p">:</span>
            <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
            <span class="n">free_cell</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">NIL</span><span class="p">:</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_one_cell</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">LABEL</span><span class="p">:</span>
            <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">);</span>
            <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">LIST</span><span class="p">:</span>
            <span class="n">free_cell</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
            <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">BUILTIN</span><span class="p">:</span>
            <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
            <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">NIL</span><span class="p">:</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>This is some wordy code, but it&rsquo;s necessary to handle all the different types
of cells. Let&rsquo;s adapt them! Remember that the only substantive difference
between <code>copy</code> and <code>copy_one</code> is that <code>copy_one</code> doesn&rsquo;t propogate through
<code>next</code> addresses!</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">copy_cell</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">LABEL</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">makecell</span><span class="p">(</span><span class="n">LABEL</span><span class="p">,</span> <span class="p">(</span><span class="n">V</span><span class="p">){</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span> <span class="p">},</span> <span class="n">copy_cell</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
        <span class="k">case</span> <span class="nl">LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">makecell</span><span class="p">(</span><span class="n">LIST</span><span class="p">,</span> <span class="p">(</span><span class="n">V</span><span class="p">){</span> <span class="p">.</span><span class="n">list</span> <span class="o">=</span> <span class="n">copy_cell</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">list</span><span class="p">)</span> <span class="p">},</span> <span class="n">copy_cell</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
        <span class="k">case</span> <span class="nl">BUILTIN</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">makecell</span><span class="p">(</span><span class="n">BUILTIN</span><span class="p">,</span> <span class="p">(</span><span class="n">V</span><span class="p">){</span> <span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="p">{</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">addr</span><span class="p">}</span> <span class="p">},</span> <span class="n">copy_cell</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
        <span class="k">case</span> <span class="nl">NIL</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="n">nil</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>and <code>copy_one_cell</code>, with the <code>next</code> members pointing to <code>&amp;nil</code>:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">copy_one_cell</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">LABEL</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">makecell</span><span class="p">(</span><span class="n">LABEL</span><span class="p">,</span> <span class="p">(</span><span class="n">V</span><span class="p">){</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span> <span class="p">},</span> <span class="o">&amp;</span><span class="n">nil</span><span class="p">);</span>
        <span class="k">case</span> <span class="nl">LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">makecell</span><span class="p">(</span><span class="n">LIST</span><span class="p">,</span> <span class="p">(</span><span class="n">V</span><span class="p">){</span> <span class="p">.</span><span class="n">list</span> <span class="o">=</span> <span class="n">copy_cell</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">list</span><span class="p">)</span> <span class="p">},</span> <span class="o">&amp;</span><span class="n">nil</span><span class="p">);</span>
        <span class="k">case</span> <span class="nl">BUILTIN</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">makecell</span><span class="p">(</span><span class="n">BUILTIN</span><span class="p">,</span> <span class="p">(</span><span class="n">V</span><span class="p">){</span> <span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="p">{</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">addr</span><span class="p">}</span> <span class="p">},</span> <span class="o">&amp;</span><span class="n">nil</span><span class="p">);</span>
        <span class="k">case</span> <span class="nl">NIL</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="n">nil</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>You might notice a problem right away with this! <code>makecell</code> allocates memory
for the contents of a cell, but those contents sometimes include pointers to
strings that also need to be allocated! I can pull this into a helper function
that allocates some memory, copies a string into it.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">char</span> <span class="o">*</span><span class="nf">scpy</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span> <span class="n">l</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">out</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>I&rsquo;ll plop this into <code>utils.c</code> and use it in the <code>env.c</code> file to return a copy instead of the original.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="p">...</span>
            <span class="k">return</span> <span class="n">copy_one_cell</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div>

<p>Now, everything cleans itself up correctly when it is evaluated.</p>

<blockquote>
<h2 id="a-word-about-perf">A word about perf</h2>

<p>You might be reading this and saying something like: &ldquo;Hey, making copies all
the time seems pretty wasteful, and malloc system calls can be pretty
expensive, and this isn&rsquo;t very performative, you&rsquo;re an idiot!&rdquo;</p>

<p>I wouldn&rsquo;t really argue with you! (except <em>maybe</em> on the idiot thing, which
seems a little harsh). All of these things, in fact, are very very true.
There are lots of opportunities for making this faster, better, and generally
more perfomant, in fact, I&rsquo;m trying to keep a running tally of those things
in my head, and am looking forward to a lot of refactoring after I get
everything working! The goal of this iteration is clarity and consistency in
implementation, not performance. I&rsquo;d love to make that a priority later
though!</p>
</blockquote>

<hr>

<h2 id="let-s-set">Let&rsquo;s set.</h2>

<p>So, I&rsquo;ve got a way to get stuff out of an <code>Env</code>, but I&rsquo;m currently setting it by hand.
This is silly! I want a corresponding <code>set</code> function that takes an env, and a
key value pair, and inserts a new entry into that Env (at the head of it, which
becomes important later for scoping!) and then updates that Env&rsquo;s internal
<code>head</code> member to point to this new entry.</p>

<p>First, the function signature, which I had already put into the <code>h</code> file:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">set</span><span class="p">(</span><span class="n">Env</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">C</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">C</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div>

<p>Except, you know what? now that I think of it, this function needn&rsquo;t return
anything at all, since if it fails I want to exit. And though I&rsquo;m always going
to be returning a value, I might as well pass in a string so I don&rsquo;t have to
muck around with new cells.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="n">Env</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">C</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div>

<p>So I&rsquo;ll make a new entry out of the key value pair with my shiny <code>new_entry()</code> function:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="n">Env</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">C</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">new_entry</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>And I&rsquo;ll tell the new_entry that its <code>next</code> member should be the current head
of the Env:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="n">Env</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">C</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Entry</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">new_entry</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">new</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">Env</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>And I&rsquo;ll tell the Env that its head is now the new entry:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="n">Env</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">C</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Entry</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">new_entry</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">new</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">Env</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
    <span class="n">env</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>And that&rsquo;s it! If the <code>malloc</code>ing happening inside of new_entry fails, I&rsquo;ll have
an <code>exit(1)</code> call to cath it. I&rsquo;ve been falling behind on setting up good exit error
messaging, but I&rsquo;ll make a sweep on that at some point.</p>

<p>Back in the <code>eval_file</code> function, then, I can do this:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">Env</span> <span class="o">*</span><span class="n">env</span> <span class="o">=</span> <span class="n">new_env</span><span class="p">();</span>
<span class="n">set</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;hi&quot;</span><span class="p">,</span> <span class="n">truth</span><span class="p">());</span>
<span class="n">set</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;mom&quot;</span><span class="p">,</span> <span class="n">truth</span><span class="p">());</span>
</code></pre></div>

<p>And I have an env with two entries!</p>

<pre><code>hi
mom
</code></pre>

<p>Gives me:</p>

<pre><code>#t
#t
</code></pre>

<p>Success!</p>

<p>There&rsquo;s one interesting aspect of this env thing that is implicit in its design! What if I do this?</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">Env</span> <span class="o">*</span><span class="n">env</span> <span class="o">=</span> <span class="n">new_env</span><span class="p">();</span>
<span class="n">set</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;hi&quot;</span><span class="p">,</span> <span class="n">truth</span><span class="p">());</span>
<span class="n">set</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;hi&quot;</span><span class="p">,</span> <span class="n">empty_list</span><span class="p">());</span>
</code></pre></div>

<p>Two entries with the same key but different values. Now, in sild land, what
will I get if I evaluate the LABEL <code>hi</code>? How does my <code>get</code> function choose?</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">get</span><span class="p">(</span><span class="n">Env</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">C</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Entry</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">scmp</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">copy_one_cell</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>I didn&rsquo;t put any special logic in there- how does it know which one? Well&hellip;</p>

<pre><code>()
</code></pre>

<p>It returns the first one it finds! This doesn&rsquo;t seem like a big deal, but in a
way it will be the backbone of my language&rsquo;s variable scoping, later on.</p>

<hr>

<p>Now that I have all these helpers defined, and a concept of an Env defined,
it&rsquo;s a short walk in the park to implement a new <code>sild</code> builtin function that
can utilize them! The signature will look like all the builtin functions:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">define</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">operand</span><span class="p">,</span> <span class="n">Env</span> <span class="o">*</span><span class="n">env</span><span class="p">);</span>
</code></pre></div>

<p>it will take two arguments, a key and a value. (in sild land):</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">define</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">operand</span><span class="p">,</span> <span class="n">Env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">arity_check</span><span class="p">(</span><span class="s">&quot;define&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">operand</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>The key <em>must</em> be a label:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">define</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">operand</span><span class="p">,</span> <span class="n">Env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">arity_check</span><span class="p">(</span><span class="s">&quot;define&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">operand</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">operand</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">LABEL</span><span class="p">)</span> <span class="p">{</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Then it will <code>set</code> the arguments to a key value pair inside the given env,
evalling the 2nd operand.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">define</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">operand</span><span class="p">,</span> <span class="n">Env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">arity_check</span><span class="p">(</span><span class="s">&quot;define&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">operand</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">operand</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">LABEL</span><span class="p">)</span> <span class="p">{</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">set</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">operand</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="n">eval</span><span class="p">(</span><span class="n">operand</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">env</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<p>Then it will free the label! I don&rsquo;t need to free the evalled operand, because
that will serve as the master copy in the env.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">define</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">operand</span><span class="p">,</span> <span class="n">Env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">arity_check</span><span class="p">(</span><span class="s">&quot;define&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">operand</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">operand</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">LABEL</span><span class="p">)</span> <span class="p">{</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">set</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">operand</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="n">eval</span><span class="p">(</span><span class="n">operand</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">env</span><span class="p">));</span>
    <span class="n">free_one_cell</span><span class="p">(</span><span class="n">operand</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>And that&rsquo;s really that! It has to return something, so how about nil? I won&rsquo;t
be doing anything with that return value ever (you will see why soon!)</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">define</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">operand</span><span class="p">,</span> <span class="n">Env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">arity_check</span><span class="p">(</span><span class="s">&quot;define&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">operand</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">operand</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">LABEL</span><span class="p">)</span> <span class="p">{</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">set</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">operand</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="n">eval</span><span class="p">(</span><span class="n">operand</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">env</span><span class="p">));</span>
    <span class="n">free_one_cell</span><span class="p">(</span><span class="n">operand</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">nil</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Now, I can add <code>define</code> into the reader, just like the other ones:</p>

<pre><code>...
} else if (scmp(token, &quot;define&quot;)) {
    out = makecell(BUILTIN, (V){ .func = {token, define} }, &amp;nil);
...
</code></pre>

<p>And lo and behold, this totally works!</p>

<pre><code>(define thing (quote (1 2 3)))
thing
</code></pre>

<p>Will print out</p>

<pre><code>(1 2 3)
</code></pre>

<p>And I could use <code>thing</code> wherever it makes sense to use (1 2 3)</p>

<pre><code>(define thing (quote (1 2 3)))
(define otherthing (quote 0))
(cons otherthing thing)
</code></pre>

<p>yields:</p>

<pre><code>(0 1 2 3)
</code></pre>

<p>You can even compose them! For example:</p>

<pre><code>(define thing (quote (1 2 3)))
(define otherthing (quote 0))
(define wat (cons otherthing thing))
wat
</code></pre>

<p>Now, <code>wat</code> is equal to <code>(0 1 2 3)</code>!</p>

<h2 id="one-more-thing">One more thing</h2>

<p>Well, a couple more things! <code>define</code> is the first builtin function that has any
sort of side effect- in this case, it is mutating the only possessor of state
in the running program: the top level environment. Its return value, if it were
a C function, would be <code>void</code>, since it&rsquo;s being called only for those side
effect. I don&rsquo;t have a <code>void</code> type in sild (yet?), but I assigned it to return
<code>nil</code> as an expediency. To see why this might be problematic, consider:</p>

<pre><code>(cons (quote 1) (define thing (quote ())))
</code></pre>

<p>This, er, sort of makes sense, right? You would kind of half expect this to
return</p>

<pre><code>(1)
</code></pre>

<p>Since <code>thing</code> is supposed to be equal to <code>()</code> now, right?</p>

<p>It doesn&rsquo;t, since <code>define</code> is returning <code>nil</code>, <code>cons</code> really gets called on:</p>

<pre><code>(cons (quote 1))
</code></pre>

<p>I don&rsquo;t know&hellip; should define return its label? Blargh&hellip;</p>

<p>This is venturing into some interesting language design question territory, and
I&rsquo;m not ready to make a decision! I am going to default to parity with scheme,
which solves this problem by making <code>define</code> to return <code>undefined</code>, which is
kind of funny, and <em>disallowing</em> define statements outside of the top level
forms.</p>

<p>This looks a little funny compared to the other calls, but i can catch this in
the reader step by throwing an error if the reader encounters a <code>define</code>
keyword when the depth is greater than 1!</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="p">...</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scmp</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="s">&quot;define&quot;</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error: define found in inner form.&quot;</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">makecell</span><span class="p">(</span><span class="n">BUILTIN</span><span class="p">,</span> <span class="p">(</span><span class="n">V</span><span class="p">){</span> <span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="p">{</span><span class="n">token</span><span class="p">,</span> <span class="n">define</span><span class="p">}</span> <span class="p">},</span> <span class="o">&amp;</span><span class="n">nil</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div>

<p>This solves the problem. Defines will now only be able to happen in the top
level, and I don&rsquo;t really need to make another sild language void type or
whatever, since I&rsquo;ll never be able to call define anywhere that would matter.</p>

<p>I can even have the C function <code>define</code> return <code>void</code>, and all will be well.</p>

<pre><code>void define(C *operand, Env *env) {
    arity_check(&quot;define&quot;, 2, operand);
    if (operand-&gt;type != LABEL) {
        fprintf(stderr, &quot;define expected a LABEL as its first argument and did not get one\n&quot;);
        exit(1);
    }
    set(env, operand-&gt;val.label, eval(operand-&gt;next, env));
    free_one_cell(operand);
}
</code></pre>

<p>&ldquo;But what about <code>delete()</code> in the env?&rdquo;</p>

<p>I don&rsquo;t want to expose a deletion function to the sild space just yet, if at
all, once a variable is bound using <code>define</code> in the global environment, I want
it to remain that way. But I do need to free the environment itself after I&rsquo;m
done with it, or I&rsquo;ll have a memory leak.</p>

<p>Just as I free the results of an evaluation of a form after I don&rsquo;t need it anymore in <code>eval_file</code></p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">void</span> <span class="nf">eval_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error opening file: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
        <span class="n">exit</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">C</span> <span class="o">*</span> <span class="n">c</span><span class="p">;</span>

    <span class="n">Env</span> <span class="o">*</span><span class="n">env</span> <span class="o">=</span> <span class="n">new_env</span><span class="p">();</span>
    <span class="k">while</span><span class="p">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
        <span class="n">free_cell</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>           <span class="c1">// here!</span>
    <span class="p">}</span>

    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>So too will I free the environment I created for that file after I&rsquo;m done
reading the file! It will go here:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">void</span> <span class="nf">eval_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error opening file: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
        <span class="n">exit</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">C</span> <span class="o">*</span> <span class="n">c</span><span class="p">;</span>

    <span class="n">Env</span> <span class="o">*</span><span class="n">env</span> <span class="o">=</span> <span class="n">new_env</span><span class="p">();</span>
    <span class="k">while</span><span class="p">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
        <span class="n">free_cell</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">free_env</span><span class="p">(</span><span class="n">env</span><span class="p">);</span>              <span class="c1">// here!</span>

    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>And it will look like this:</p>

<pre><code>void free_env(Env* env) {
    // get the first entry in the env
    Entry *cur = env-&gt;head;

    //holding place for the next entry
    Entry *next;

    while (cur) {
        // free the char* key
        free(cur-&gt;key);

        // free the cell that is the value
        free_cell(cur-&gt;value);

        // hold pointer to next cell here, so that I can ...
        next = cur-&gt;next;

        // free the entry space for cur
        free(cur);

        // reassign cur to what was its next entry...
        cur = next;
    }
    // finally, when there are no more entries, free the environment itself.
    free(env);
}
</code></pre>

<p>Now, I am being a good memory citizen and cleaning up after myself when I am
done reading all the forms in a file.</p>

                </div>
            </article>
        </div>
    </body>
</html>
