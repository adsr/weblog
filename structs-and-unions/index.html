<!DOCTYPE html>
<html lang="en-us">

    <head>
    <title>Structs and Unions</title>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="icon" href="https://blog.jfo.click/images/jeff.ico" type="image/x-icon" />
    <style type="text/css">
        @font-face {
    font-family: "etbook";
    src: url("https://blog.jfo.click/css/et-book.woff") format('woff');
}


    </style>
    <link rel="stylesheet" href="https://blog.jfo.click/css/style.css">
    <link rel="stylesheet" href="https://blog.jfo.click/css/solarized-dark.css">
    <link href="" rel="alternate feed" type="application/rss+xml" title="RSS Feed for blog.jfo.click" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
         (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
         m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
         })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-77907408-1', 'auto');
        ga('send', 'pageview');
    </script>
</head>


    <body>
        <div id="content">
            <header class="site-header">
    <a href="https://blog.jfo.click/"><h4>archive</h4></a> &mdash;
    <a href="https://blog.jfo.click/about"><h4>about</h4></a> &mdash;
    <a href="https://blog.jfo.click/feed.xml"><h4>rss</h4></a>
</header>

            <article>
                <h1>Structs and Unions</h1>
                <sub>May 30, 2016 </sub>
                <div>
                    

<p>C has a variety of <a href="https://en.wikipedia.org/wiki/C_data_types">built in data
types</a>. But let&rsquo;s pick just two to
mess around with: a <code>long long int</code> and a <code>char</code>.</p>

<p>A <code>long long int</code> (or just <code>long long</code>) is specified to be at <em>least</em> 64 bits
in size. That means that if we call <code>sizeof</code> on it, we should get at <em>least</em> 8
bytes, since 8 * 8 = 64.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Sure enough, this outputs:</p>

<pre><code>8
</code></pre>

<p>A <code>char</code> is, by its name, one &lsquo;character&rsquo;&hellip; but this is a bit misleading. In
ye olden days, a character was never more than one byte long, since the <a href="http://www.asciitable.com/">ascii
standard</a> specified only a very small set of
symbols, and they could all be accomodated in a single byte. Nowadays, a more standard
encoding is <a href="https://www.youtube.com/watch?v=MijmeoH9LT4">Unicode</a>, in which
many thousands of symbols can be represented by strings of bytes of somewhat
arbitrary length. It is no longer accurate, then, to say that a <code>char</code>, in the
sense of &ldquo;character&rdquo;, is only one byte long, but the naming convention persists
in C, and the <code>char</code> <em>type</em> <strong>is</strong> always one byte long. It would
be drastically more accurate to call that type a <code>byte</code>, but here we are.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>yields:</p>

<pre><code>1
</code></pre>

<h2 id="structs">Structs</h2>

<p>A struct is a way for the programmer to bundle types together in one
<em>structure</em>. Let&rsquo;s say we wanted to represent a point in two dimensional space,
for example. A point is fully articulated when we have both an x value and a y
value. A <code>Point</code> struct might look like this:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>We coud then use <code>struct Point</code> to declare a point variable just like any other type.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">struct</span> <span class="n">Point</span> <span class="n">x</span><span class="p">;</span>
</code></pre></div>

<p>How big is <code>x</code>, now, do you think? a <code>struct Point</code> contains two ints. How big is an int?</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<pre><code>4
</code></pre>

<p>Looks like it is four bytes long. A <code>struct Point</code>, then, should be 8 bytes long, right?</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Point</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>And indeed it is.</p>

<pre><code>8
</code></pre>

<p>What about a point in 5 dimensional space? We would need 5 <code>int</code>s to fully
specify such a point, right?</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Point</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>If you&rsquo;re guessing this is 20 bytes long, well pat yourself on the back!</p>

<pre><code>20
</code></pre>

<p>Normally, when we declare a var, we can simply assign a value to it like this:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</code></pre></div>

<p>Or even initialize it at the time of declaration:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</code></pre></div>

<p>For structs, we can do the same type of thing! Let&rsquo;s look at that 2d point again.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Those <code>x</code> and <code>y</code> values are referred to as <em>members</em> of that struct. To access
them for reading or writing, we can use dot notation.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">struct</span> <span class="n">Point</span> <span class="n">mypoint</span><span class="p">;</span>
<span class="n">mypoint</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">mypoint</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</code></pre></div>

<p>Now, <code>mypoint</code> is fully initialized, and equal to the point <code>(2, 5)</code> in regular
notation. You could do this in any order.</p>

<p>What about initializing the struct at the time of declaration, in one line?
That looks like this, with an inlined static array:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">struct</span> <span class="n">Point</span> <span class="n">mypoint</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>
</code></pre></div>

<p>If you simply list the member values in order like that, it will work, but you
can also specify which one is which by being explicit:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">struct</span> <span class="n">Point</span> <span class="n">mypoint</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">};</span>
</code></pre></div>

<hr>

<p>Let&rsquo;s go back to those two types from the beginning. What if we wanted a
<code>struct</code> that contained one of each?</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">struct</span> <span class="n">Thingy</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">letter</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">number</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Who knows why we would need that, but whatever. The size of this struct in
memory is going to be equal to the sum of its members&rsquo; sizes. So a <code>char</code> (1
byte) plus a <code>long long</code> (8 bytes), so 9 bytes.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Thingy</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">letter</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">number</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Thingy</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Outputs:</p>

<pre><code>16
</code></pre>

<p>Wait huh? This actually surprised me when I was writing this post! Because a
<code>long long</code> is 8 bytes long, the <code>char</code> member must be offset by the same
distance for optimizations! The &lsquo;true size&rsquo; of the <code>letter</code> member is still
just one byte, but the space the member must take up in memory is now 8 bytes.
I do not fully understand this yet, but it looks like <a href="http://c-faq.com/struct/align.esr.html">this
document</a> explains the historical
context and reasoning. Interesting! There appears to be some <a href="http://stackoverflow.com/questions/14332633/attribute-packed-v-s-gcc-attribute-alignedx">black
magic</a>
that will force the compiler to do that without padding, but in the
absence of a very good reason, this seems unneccesary.</p>

<h2 id="unions">Unions</h2>

<p><code>union</code> types look and behave an awful lot like <code>struct</code>s do, syntactically, but
there is a very important difference. Whereas structs are a collection of
members that are assembled together in memory side by side, <code>unions</code> can <em>only ever contain
one of their members at any one time</em>. As such, a union type will be the size of its
<em>largest</em> member, in order to accomodate the biggest thing it will ever need to hold.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">union</span> <span class="n">Thingy</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p><code>Thingy</code> looks like it has two <code>ints</code> inside of it. If this were a <code>struct</code>, it
would, and it would need to be as big as two ints to hold both of them! But
since this is a union, it will only ever need to hold one or the other.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">union</span> <span class="n">Thingy</span> <span class="n">myunion</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">myunion</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Will output: <code>4</code>! In fact, so will this:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">union</span> <span class="n">Thingy</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">d</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">e</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">f</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">union</span> <span class="n">Thingy</span> <span class="n">myunion</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">myunion</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>You get the idea!</p>

<hr>

<p>Let&rsquo;s look at a weird thing about unions!</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">union</span> <span class="n">Thingy</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">union</span> <span class="n">Thingy</span> <span class="n">myunion</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">156</span> <span class="p">};</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">myunion</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">myunion</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Outputs:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="mi">156</span>
<span class="mi">156</span>
</code></pre></div>

<p>Because <code>myunion.x</code> and <code>myunion.y</code> are referencing the <em>exact same memory
space</em>. Because they are both <code>int</code>s, this is fine!</p>

<p>How about this one?</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">union</span> <span class="n">Thingy</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">letter</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">number</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">union</span> <span class="n">Thingy</span> <span class="n">myunion</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">myunion</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>No surprise this time! Because a <code>long long</code> is by far the largest member of
this <code>union</code>, an instance of this type will have a size that is the same as the
<code>long long</code>, which is 8.</p>

<pre><code>8
</code></pre>

<p>I will leave you with this bit of weirdness.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">union</span> <span class="n">Thingy</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">letter</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">number</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">union</span> <span class="n">Thingy</span> <span class="n">myunion</span><span class="p">;</span>

    <span class="n">myunion</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">Thingy</span><span class="p">){</span> <span class="p">.</span><span class="n">letter</span> <span class="o">=</span> <span class="sc">&#39;!&#39;</span> <span class="p">};</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">myunion</span><span class="p">.</span><span class="n">letter</span><span class="p">);</span>  <span class="c1">// !</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lli</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">myunion</span><span class="p">.</span><span class="n">number</span><span class="p">);</span> <span class="c1">// 33</span>

    <span class="n">myunion</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">Thingy</span><span class="p">){</span> <span class="p">.</span><span class="n">number</span> <span class="o">=</span> <span class="mi">33</span> <span class="p">};</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">myunion</span><span class="p">.</span><span class="n">letter</span><span class="p">);</span>  <span class="c1">// !</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lli</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">myunion</span><span class="p">.</span><span class="n">number</span><span class="p">);</span> <span class="c1">// 33</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>All of these are just different ways to organize and get at the exact same
data. In every case above, the same memory is being assigned the same values,
but we&rsquo;re accessing it and interpreting it in different ways.</p>

                </div>
            </article>
        </div>
    </body>
</html>
