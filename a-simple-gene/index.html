<!DOCTYPE html>
<html lang="en-us">

    <head>
    <title>a simple gene</title>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="icon" href="https://blog.jfo.click/images/jeff.ico" type="image/x-icon" />
    <style type="text/css">
        @font-face {
    font-family: "etbook";
    src: url("https://blog.jfo.click/css/et-book.woff") format('woff');
}


    </style>
    <link rel="stylesheet" href="https://blog.jfo.click/css/style.css">
    <link href="" rel="alternate feed" type="application/rss+xml" title="RSS Feed for blog.jfo.click" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css">
</head>


    <body>
        <div id="content">
            <header class="site-header">
    <a href="https://blog.jfo.click/"><h4>archive</h4></a> &mdash;
    <a href="https://blog.jfo.click/about"><h4>about</h4></a> &mdash;
    <a href="https://blog.jfo.click/feed.xml"><h4>rss</h4></a>
</header>

            <article>
                <p>
                    <h1>a simple gene</h1>
                    <sub>April 23, 2014 </sub>
                <p>
                <div>
                    <p>I had a goodly and productive day today, by which I mean that I:</p>

<ul>
<li>Had a thing I wanted to do</li>
<li>Did it.</li>
</ul>

<p>How rewarding! The &ldquo;thing&rdquo; was:</p>

<ul>
<li>The fizzbuzz of genetic algorithms.</li>
</ul>

<p>There were a lot of intermediate steps, of course, like these:</p>

<ul>
<li>talk to Alex about it a bunch</li>
<li>scratch head</li>
<li>talk to Alex some more</li>
</ul>

<p>and these:</p>

<ul>
<li>fail.</li>
<li>fail.</li>
<li>notice I&rsquo;m using completely wrong function for thing; fail.</li>
<li>succeed.</li>
</ul>

<p>All in all, it struck a balance.</p>

<p>Now, I don&rsquo;t mean I wrote fizzbuzz <em>as</em> a genetic algorithm (and I&rsquo;m going to space here for a second to avoid nerd sniping myself: lalala&hellip;.) but rather asked the question- what is the simplest implementation that I can think of <em>of</em> a genetic algorithm, which qualifies as such?</p>

<p>Here is what you need to make it work:</p>

<ul>
<li>A defined type of &ldquo;gene,&rdquo; that is organized into</li>
<li>&ldquo;generations,&rdquo; or sets of genes of a constant size.</li>
<li>A metric for evaluating the fitness of a given gene, and</li>
<li>A way to change genes slightly, whether through mutation, recombination, or some other method.</li>
</ul>

<p>I&rsquo;ll come back to those momentarily, but Alex suggested this as a good first go:</p>

<pre><code>A &quot;gene&quot; is a string of n length of bits (1 or 0).
They can be randomized or seeded with a starting gene (such as all 0's)

A &quot;generation&quot; is 100 genes.
The fitness of a gene is denoted by the number of 1's in the string.

Write a mutative algorithm that moves towards the base case of all 1's.
</code></pre>

<p>Let&rsquo;s start with generating the basic material: one gene! This solution is in Clojure:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">new-gene</span> <span class="p">[]</span>
   <span class="c1">; (repeatedly 50 #(rand-int 2)))</span>
   <span class="p">(</span><span class="nb">take </span><span class="mi">50</span> <span class="p">(</span><span class="nb">repeat </span><span class="mi">0</span><span class="p">)))</span>
</code></pre></div>

<p>I&rsquo;ve given a length of 50. The commented out line would generate random bits, and the line at the bottom would generate a seq of all 0&rsquo;s. Now to dump those into our first generation:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">generation</span> <span class="p">[]</span>
   <span class="p">(</span><span class="nf">repeatedly</span> <span class="mi">100</span> <span class="nv">new-gene</span><span class="p">)))</span>
</code></pre></div>

<p>In English: &ldquo;Take the first one hundred elements in the sequence generated by repeatedly calling the new gene function.&rdquo; This gives us a list of 100 genes of 50 bits each.</p>

<p>Now we need to evaluate each gene for fitness; remember that our metric is simply &ldquo;the more 1&rsquo;s the better.&rdquo;</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">fitness</span> <span class="p">[</span><span class="nv">gene</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">= </span><span class="mi">1</span> <span class="nv">%</span><span class="p">)</span> <span class="nv">gene</span><span class="p">)))</span>
</code></pre></div>

<p>Matt helpfully points out that in this case, the above function could be rewritten as:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">fitness</span> <span class="p">[</span><span class="nv">gene</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">apply + </span><span class="nv">gene</span><span class="p">))</span>
</code></pre></div>

<p>Which achieves the same result by summing up all of the values in the gene instead of just counting the 1&rsquo;s.</p>

<p>And it is straightforward to map this function over all the genes in our generation:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">evaluate-generation</span> <span class="p">[</span><span class="nv">generation</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">map</span>
    <span class="nv">fitness</span>
    <span class="nv">generation</span><span class="p">))</span>
</code></pre></div>

<p>Hmmm&hellip; good, but not exactly what we want just yet. We now have a list of the fitness of each gene, but this information does us no good in a vacuum&hellip; let&rsquo;s try reordering the original generation <em>by</em> fitness, instead. By default, <code>sort-by</code> goes least to greatest, so I will also reverse that output.</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">evaluate-generation</span> <span class="p">[</span><span class="nv">generation</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">reverse</span>
    <span class="p">(</span><span class="nf">sort-by</span>
      <span class="nv">fitness</span>
      <span class="nv">generation</span><span class="p">))</span>
</code></pre></div>

<p>Or, even better:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">evaluate-generation</span> <span class="p">[</span><span class="nv">generation</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">sort-by </span><span class="nv">fitness</span> <span class="nb">&gt; </span><span class="nv">generation</span><span class="p">))</span>
</code></pre></div>

<p>Now we&rsquo;re getting somewhere.</p>

<p>Since we have an ordered-by-fitness list of genes, we want to cull away the least fit and allow the most fit to procreate forward. A good way to accomplish this is to simply discard the bottom half, and since this is a lazy sequence we can take just the first half of it to achieve the desired effect:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">evaluate-generation</span> <span class="p">[</span><span class="nv">generation</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">take</span>
    <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">count </span><span class="nv">generation</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">sort-by </span><span class="nv">fitness</span> <span class="nb">&gt; </span><span class="nv">generation</span><span class="p">)))</span>
</code></pre></div>

<p>Once again, English: &ldquo;Take the top half of the generation of genes sorted by fitness.&rdquo;</p>

<p>Now comes the fun part! We need to introduce some type of variation in the proceeding generation. There are plenty of ways to do this, but I want to start with the most fundamental: introducing random mutations.</p>

<p>To start- a function to perform that action on a single bit:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">mutate</span> <span class="p">[</span><span class="nv">g</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">rand-int </span><span class="mi">100</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">bit-flip</span> <span class="nv">g</span> <span class="mi">0</span><span class="p">)</span>
      <span class="nv">g</span><span class="p">))</span>
</code></pre></div>

<p>Paraphrased: &ldquo;If the result of calling a random number between 1 and 100 is 1, then &ldquo;bit-flip&rdquo; the input. If it is a 1, it becomes a 0. If it is a 0, it becomes a 1.&rdquo;</p>

<p>Now to map that function over an entire gene:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span></span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">gene</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">map</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">g</span><span class="p">]</span> <span class="nv">mutate</span> <span class="nv">g</span><span class="p">)</span>
    <span class="nv">gene</span><span class="p">))</span>
</code></pre></div>

<p>I have made these functions anonymous because I am going to go ahead and skip a step by mapping the above function over an entire generation all at once, like this.</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">mutate-gen</span> <span class="p">[</span><span class="nv">generation</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">map</span>
   <span class="o">#</span><span class="p">(</span><span class="nb">map </span><span class="nv">mutate</span> <span class="nv">%</span><span class="p">)</span>
   <span class="nv">generation</span><span class="p">))</span>
</code></pre></div>

<p>This will output a new list of the same length of its input, each of whose bit&rsquo;s will have had a <sup>1</sup>&frasl;<sub>100</sub> chance of being flipped.</p>

<p>To get a new generation, therefore, the whole instruction set looks like this:</p>

<pre><code>Start from somewhere (in our case, all zeros.)
evaluate all genes for fitness and discard the bottom scoring half.
replace the discarded half with a mutated version of the top half,
where each bit in the top half had a 1/100 chance of flipping.
repeat until the &quot;objective&quot; has been reached.
</code></pre>

<p>Alex points out that under most use cases for this type of algorithm, the &ldquo;objective&rdquo; is not stricly defined. It is always, in essence, to &ldquo;maximize fitness.&rdquo; Because the fitness of these genes is evaluated on such a simple metric, the objective is obvious (MOAR ONES!).</p>

<p>Here is the function that strings all of these together and returns a new generation, mutations and all:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">tng</span> <span class="p">[</span><span class="nv">generation</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">ng</span> <span class="p">(</span><span class="nf">evaluate-generation</span> <span class="nv">generation</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">concat </span><span class="nv">ng</span>
            <span class="p">(</span><span class="nf">mutate-gen</span> <span class="nv">ng</span><span class="p">))))</span>
</code></pre></div>

<p>And here is the last function, which recurs until a perfect output of all 1&rsquo;s is generated:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">go</span> <span class="p">[</span><span class="nv">generation</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">fitness</span> <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nf">evaluate-generation</span> <span class="nv">generation</span><span class="p">)))</span> <span class="mi">50</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nf">evaluate-generation</span> <span class="nv">generation</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">do</span>
      <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nf">evaluate-generation</span> <span class="nv">generation</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nf">tng</span> <span class="nv">generation</span><span class="p">)))))</span>
</code></pre></div>

<p>Notice I had a debugging line in there to print out the fitness of each gene.</p>

<p>That&rsquo;s that! If you are curious what the output looks like, you can see a round <a href="/misc/output.txt">here</a>. Each line is the top scoring gene of that generation. Computation time varies, but it generally takes about the same number of generations to reach the objective.</p>

<p><a href="https://github.com/urthbound/genotic">Github repo here</a>; Clojure advice to optimize for readability and idiom is greatly welcome.</p>

                </div>
            </article>
        </div>
    </body>
</html>
