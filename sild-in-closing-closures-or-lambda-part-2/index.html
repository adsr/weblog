<!DOCTYPE html>
<html lang="en-us">

    <head>
    <title>Sild; In closing, closures (or, lambdas p.2)</title>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="icon" href="https://blog.jfo.click/images/jeff.ico" type="image/x-icon" />
    <style type="text/css">
        @font-face {
    font-family: "etbook";
    src: url("https://blog.jfo.click/css/et-book.woff") format('woff');
}


    </style>
    <link rel="stylesheet" href="https://blog.jfo.click/css/style.css">
    <link href="" rel="alternate feed" type="application/rss+xml" title="RSS Feed for blog.jfo.click" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css">
</head>


    <body>
        <div id="content">
            <header class="site-header">
    <a href="https://blog.jfo.click/"><h4>archive</h4></a> &mdash;
    <a href="https://blog.jfo.click/about"><h4>about</h4></a> &mdash;
    <a href="https://blog.jfo.click/feed.xml"><h4>rss</h4></a>
</header>

            <article>
                <p>
                    <h1>Sild; In closing, closures (or, lambdas p.2)</h1>
                    <sub>July 31, 2016 </sub>
                <p>
                <div>
                    

<p>Consider this:</p>
<div class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span></span><span class="p">(</span><span class="k">define </span><span class="nv">conser</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">))))</span>
</code></pre></div>

<p>And now,</p>
<div class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span></span><span class="p">(</span><span class="nf">conser</span> <span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</code></pre></div>

<p>Will return</p>
<div class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span></span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
</code></pre></div>

<p>Furthermore,</p>
<div class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span></span><span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</code></pre></div>

<p>And now,</p>
<div class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span></span><span class="p">(</span><span class="nf">conser</span> <span class="ss">&#39;a</span> <span class="nv">z</span><span class="p">)</span>
</code></pre></div>

<p>Will evaluate <code>z</code> in the global env before passing it to <code>conser</code>, returning:</p>
<div class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span></span><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
</code></pre></div>

<p>But what about this?</p>
<div class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span></span><span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">conser</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">z</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nf">conser</span> <span class="ss">&#39;a</span><span class="p">))</span>
</code></pre></div>

<p>You&rsquo;ll notice, that at the time of <code>conser</code>&rsquo;s invocation, <code>z</code> is defined in the
global environment. Unlike the second example above, however, <code>z</code> is <em>not</em>
being evaluated in that environment. The <code>z</code> here is being evaluated within the
frame environment created by <code>apply_proc</code> during the evaluation <code>(conser 'a)</code>,
an environment that currently has no assignment for <code>z</code>.</p>

<p>And so we get:</p>

<pre><code>Error: unbound label: z
</code></pre>

<p>This is obviously not the behavior we would expect! The interpreter <em>should</em> be
examining the frame for <code>z</code>, and then when not finding it, trying to look it up
in the enclosing environment, which in this case is the global one!</p>

<p>This actually turns out to be a fairly easy fix!</p>

<p>Right now, <code>get()</code> looks like this:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">get</span><span class="p">(</span><span class="n">Env</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">C</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Entry</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">scmp</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">copy_one_cell</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>You can see right there that if a variable is not found in an environment, then
it just returns NULL, and that&rsquo;s it!</p>

<p>In a pattern that is becoming fairly familiar by now, we need yet another
linked list of environments. An environment should be linked to whatever
environment it is being evaluated inside.</p>

<p>Currently, an <code>Env</code> is a struct that contains just one pointer:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Env</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Entry</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Env</span><span class="p">;</span>
</code></pre></div>

<p>We&rsquo;ll add a <code>next</code> member.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Env</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Entry</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Env</span><span class="p">;</span>
</code></pre></div>

<p>and initialize it to <code>NULL</code> in the &ldquo;constructor&rdquo; function:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">Env</span> <span class="o">*</span><span class="nf">new_env</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Env</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Env</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">};</span>
    <span class="n">out</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">out</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Now, back in the get function, simply check and see if there is a next member
to attempt to look up a given value in if it isn&rsquo;t found in the provided Env:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">get</span><span class="p">(</span><span class="n">Env</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">C</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Entry</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">scmp</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">copy_one_cell</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">get</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>The final change to hook all of this up lives back in <code>apply_proc()</code>, which
currently looks like:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">static</span> <span class="n">C</span> <span class="o">*</span><span class="nf">apply_proc</span><span class="p">(</span><span class="n">C</span><span class="o">*</span> <span class="n">proc</span><span class="p">,</span> <span class="n">Env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">C</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">proc</span><span class="p">.</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">list</span><span class="p">;</span>
    <span class="n">C</span> <span class="o">*</span><span class="n">curarg</span> <span class="o">=</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">arity</span> <span class="o">=</span> <span class="n">count_list</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">numpassed</span> <span class="o">=</span> <span class="n">count_list</span><span class="p">(</span><span class="n">curarg</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">arity</span> <span class="o">!=</span> <span class="n">numpassed</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;arity error on proc application</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">frame</span> <span class="o">=</span> <span class="n">new_env</span><span class="p">();</span>
    <span class="n">C</span> <span class="o">*</span><span class="n">nextarg</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arity</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nextarg</span> <span class="o">=</span> <span class="n">curarg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">curarg</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nil</span><span class="p">;</span>
        <span class="n">set</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="n">eval</span><span class="p">(</span><span class="n">curarg</span><span class="p">,</span> <span class="n">env</span><span class="p">));</span>
        <span class="n">curarg</span> <span class="o">=</span> <span class="n">nextarg</span><span class="p">;</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">C</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">proc</span><span class="p">.</span><span class="n">body</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>

    <span class="n">free_cell</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">proc</span><span class="p">.</span><span class="n">args</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
    <span class="n">free_env</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>As you can see, the <code>frame</code> env that we&rsquo;ve created has no <code>next</code> member yet,
since it was initialized to NULL Before we evaluate the <code>proc</code> body inside the
frame, we just have to hook up the frame to the parent environment. One line
will do it!</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="c1">// etc...</span>

    <span class="n">frame</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">env</span><span class="p">;</span>
    <span class="n">C</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">proc</span><span class="p">.</span><span class="n">body</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>

<span class="c1">// ...etc</span>
</code></pre></div>

<p>Now, back in the example:</p>
<div class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span></span><span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">conser</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">z</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nf">conser</span> <span class="ss">&#39;a</span><span class="p">))</span>
</code></pre></div>

<p>The frame created to evalute <code>conser</code> in will have access to the global env
when it can&rsquo;t find the <code>z</code> variable inside of the frame, and it will find it, and lo</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="p">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div>

<hr>

<p>Not quite done! Consider this.</p>
<div class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span></span><span class="p">(</span><span class="k">define </span><span class="nv">conser</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">a</span><span class="p">)</span>
        <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">a</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">hello</span><span class="p">)))))</span>
</code></pre></div>

<p><code>conser</code>, now, is a function that takes an argument and <em>returns a function</em>
that, when invoked, will cons that original argument onto the list <code>'(hello)</code>.</p>

<p>Will this work?</p>
<div class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span></span><span class="p">(</span><span class="k">define </span><span class="nv">conser</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">a</span><span class="p">)</span>
        <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">a</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">hello</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">myconser</span> <span class="p">(</span><span class="nf">conser</span> <span class="ss">&#39;1</span><span class="p">))</span>

<span class="p">(</span><span class="nb">display </span><span class="nv">myconser</span><span class="p">)</span>
</code></pre></div>

<p>yields a procedure that takes no arguments but <em>contains a closed over variable
<code>a</code></em> whose definition lives in the invocation of <code>conser</code> from the line:</p>

<pre><code>(define myconser (conser '1))
</code></pre>

<p>&hellip; and it looks like this:</p>
<div class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span></span><span class="p">(</span><span class="nf">PROC</span> <span class="p">()</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">a</span> <span class="p">(</span><span class="k">quote </span><span class="p">(</span><span class="nf">hello</span><span class="p">))))</span>
</code></pre></div>

<p>This is what we would expect, but if we try to apply that function:</p>

<pre><code>(display (myconser))
</code></pre>

<pre><code>Error: unbound label: a
</code></pre>

<p>Yikes! What&rsquo;s the problem exactly?</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="c1">// etc...</span>

    <span class="n">frame</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">env</span><span class="p">;</span>
    <span class="n">C</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">proc</span><span class="p">.</span><span class="n">body</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>

<span class="c1">// ...etc</span>
</code></pre></div>

<p>This <code>-&gt;next</code> member is referring to the environment that the PROC is being
<em>evaluated inside of</em>. But that is not what we want here! We want access to the
<em>environment inside of which the procedure was <strong>defined</strong>!</em></p>

<p>Oh, if only we had a reference to that lying around!</p>

<p><em>But wait!</em></p>

<p>I had mentioned in the last post that it was <em>absolutely vital</em> to hold a
reference to a procedure&rsquo;s enclosing environment <em>inside the proc object
itself</em>. Well, this is why.</p>

<p>So, instead of this inside of apply_proc:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="n">frame</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">env</span><span class="p">;</span>
    <span class="n">C</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">proc</span><span class="p">.</span><span class="n">body</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
</code></pre></div>

<p>We want this!</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="n">frame</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">proc</span><span class="p">.</span><span class="n">env</span><span class="p">;</span>
    <span class="n">C</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">proc</span><span class="p">.</span><span class="n">body</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
</code></pre></div>

<p>::jazz hands::</p>

<p>BUT OH NO!</p>
<div class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span></span><span class="p">(</span><span class="k">define </span><span class="nv">conser</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">a</span><span class="p">)</span>
        <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">a</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">hello</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">myconser</span> <span class="p">(</span><span class="nf">conser</span> <span class="ss">&#39;1</span><span class="p">))</span>

<span class="p">(</span><span class="nb">display </span><span class="nv">myconser</span><span class="p">)</span>
</code></pre></div>

<p>Is now crashing!</p>

<p>I have written this interpreter to always clean up after itself when it is done
evaluating an expression. By design, the only persistent memory objects are
explicitly <code>defined</code> in the sild code. The implicit temporary assignments in
the frame environments used to evaluate the lambda procedures are destroyed
after the lambda is evaluated.</p>

<p>The pertinent line above, in <code>apply_proc</code>, is:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">free_env</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
</code></pre></div>

<p>This <em>is</em> the behavior I wanted! But in the case of <code>conser</code>, I need to persist the
environment that <code>myconser</code> was <em>defined</em> in so that when I try to evaluate
<code>myconser</code>, I can still look up <code>a</code> in that enclosing environment. Currently,
the procedure I am trying to apply contains a <em>danging pointer</em> to the
environment that it was defined in, because that environment was <code>free</code>&rsquo;d right
after evaluation. That&rsquo;s why the program crashes; it encounters a
<a href="https://en.wikipedia.org/wiki/Segmentation_fault">segfault</a>.</p>

<p>This is a
<a href="https://simple.wikipedia.org/wiki/Closure_(computer_science)"><em>closure</em></a>, that
enclosing environment, and maintaining them correctly is <em>difficult</em>, and non
trivial.</p>

<p>For now, simply removing that line will achieve what I want.</p>
<div class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span></span><span class="p">(</span><span class="k">define </span><span class="nv">conser</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">a</span><span class="p">)</span>
        <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">a</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">hello</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">myconser</span> <span class="p">(</span><span class="nf">conser</span> <span class="ss">&#39;1</span><span class="p">))</span>

<span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nf">myconser</span><span class="p">))</span>
</code></pre></div>

<p>Can now look up <code>a</code> and displays:</p>
<div class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span></span><span class="p">(</span><span class="mi">1</span> <span class="nv">hello</span><span class="p">)</span>
</code></pre></div>

<p>\o/</p>

<h2 id="a-preliminary-coda">A preliminary coda</h2>

<p>So&hellip; this fixes the problem with the segfault, yes, but it introduces a new
problem- a giant memory leak. Now, everytime I evaluate a procedure and create a
frame environment to help me with that, I have one more Env that may or
may not be referenced anywhere. If I have a long enough running program, these
will eventually fill up all the memory available, and the program will die.</p>

<p>To <em>really</em> solve this problem, I would have to implement a garbage collector
inside the language! I only really want to hang onto frame environments that
are referenced somewhere&hellip; if they are not referenced anywhere then I could
safely free them. This is a big project all on it&rsquo;s own and there are <a href="https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/">many ways</a>
to implement GC. If Sild were to ever be a real, useful language, it would need
to be garbage collected, somehow! (It would also need a standard library of
some sort, or at the very least, you know, numbers&hellip;)</p>

<p>As I was doing this project, this is the point when I decided I was &ldquo;done.&rdquo;</p>

<p>Not really <em>done</em> done, I would very much like to implement a garbage
collector! (and also numbers&hellip;) and likely will! But not right now.</p>

<p>My initial goal for was to implement a very basic interpreted lisp
that could express quote, car, cons, cdr, eq, atom, cond, define, display, and
lambda. I was able to do that! I learned an enormous amount along the way, and
the scope of the project creeped appropriately in order to accomodate those
goals.</p>

<p>Garbage collection, a standard library, and numerical support would be
incredibly interesting projects! But they are in a different category than what
I&rsquo;ve done so far. As are a repl, and better error handling, tail call
optimization, and a test suite&hellip;  these are all things I&rsquo;d like to do, but not
right now.</p>

<p>I&rsquo;ve recorded this whole process in painstaking detail for my future self, and
for anyone else who might be interested in the subject. I hope it&rsquo;s been
interesting! I plan to write some more posts about Sild, but for now, this
feels like the right place to stop. So, if you&rsquo;ve gotten this far, thanks for
reading!</p>

                </div>
            </article>
        </div>
    </body>
</html>
