<!DOCTYPE html>
<html lang="en-us">

    <head>
    <title>Sild; implementing some built in functions</title>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="icon" href="https://blog.jfo.clickimages/jeff.ico" type="image/x-icon" />
    <style type="text/css">
        @font-face {
    font-family: "etbook";
    src: url("https://blog.jfo.clickcss/et-book.woff") format('woff');
}


    </style>
    <link rel="stylesheet" href="https://blog.jfo.clickcss/style.css">
    <link rel="stylesheet" href="https://blog.jfo.clickcss/solarized-dark.css">
    <link href="" rel="alternate feed" type="application/rss+xml" title="RSS Feed for blog.jfo.click" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>


    <body>
        <div id="content">
            <header class="site-header">
    <a href="https://blog.jfo.click"><h4>archive</h4></a> &mdash;
    <a href="https://blog.jfo.clickabout"><h4>about</h4></a> &mdash;
    <a href="https://blog.jfo.clickfeed.xml"><h4>rss</h4></a>
</header>

            <article>
                <h1>Sild; implementing some built in functions</h1>
                <sub>June 23, 2016 </sub>
                <div>
                    <p>This post is part of a series of posts that began <a href="/sild-is-a-lisp-dialect/">here</a>.</p>

<p>Now that the eval apply loop actually <em>works</em>, I need to write some basic
functions that operate on lists in the same way my example functions
(<code>/dev/null</code> and <code>concat</code>) did. Those were just examples, I&rsquo;m not going to keep
them around.</p>

<p>I&rsquo;m going to implement the 7 most basic operations in lisp, as per Paul
Graham&rsquo;s essay <a href="http://www.paulgraham.com/rootsoflisp.html">&ldquo;The Roots of
Lisp&rdquo;</a>. I recommend reading that,
it is very thorough in describing these functions.</p>

<p>One function can operate on anyting at all:</p>

<ol>
<li><strong>quote</strong>: the identity function, expects one cell of any type and returns
whatever is passed to it unchanged.</li>
</ol>

<p>Three functions operate on lists:</p>

<ol>
<li><strong>car</strong>: expects a list, returns the first element of the list.</li>
<li><strong>cdr</strong>: expects a list, returns the list without the first element.</li>
<li><strong>cons</strong>: expects a cell of any type and a list. Returns the list with the
cell at its beginning.</li>
</ol>

<p>Three functions depend on a notion of true/false in the language (which we
haven&rsquo;t really addressed yet):</p>

<ol>
<li><strong>eq</strong>: expects two cells; returns true if they have the same value or are
both the empty list.</li>
<li><strong>atom</strong>: expects one cell, returns true if a cell is an atom or the empty list.</li>
<li><strong>cond</strong>: expects a series of lists of two elements. It evaluates the first
of each pair and returns the second of the first one that returns true.</li>
</ol>

<p>One depends on setting up an environment inside the evaluating framework:</p>

<ol>
<li><strong>define</strong>: Expects a label and any other single thing, and stores that
thing in the evaluating environment under that label. Subsequent appearances
of that label, when evall&rsquo;ed, will be resolved to a copy of that master
value.</li>
</ol>

<p>And the last is the most powerful of all- which depends on all the other
functions and makes application of arbitrary, composed functions possible, and
which I&rsquo;ll describe in much greater detail later on.</p>

<ol>
<li><strong>lambda</strong> the ultimate :)</li>
</ol>

<p>Let&rsquo;s make some of them! Specifically, the first four!</p>

<hr>

<p>The implementation of all these functions will follow the same basic pattern.
All of them will accept a cell and return a cell:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">feel_the_func</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
<span class="p">};</span>
</code></pre></div>

<p>They&rsquo;ll all perform a simple arity check against the number of inputs <em>before</em>
evaluating them:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">feel_the_func</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// arity check</span>
<span class="p">}</span>
</code></pre></div>

<p>Then they&rsquo;ll evaluate the operands (except for quote) and perform a type check
against the resulting inputs if necessary</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">feel_the_func</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// arity check</span>
    <span class="c1">// eval operands</span>
    <span class="c1">// argument type check</span>
<span class="p">}</span>
</code></pre></div>

<p>Then operate on the inputs! This can mean creating and destroying cells, or
simply stitching together the inputs in a new way and returning that.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">feel_the_func</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// arity check</span>
    <span class="c1">// eval operands</span>
    <span class="c1">// argument type check</span>
    <span class="c1">// operate on inputs</span>
<span class="p">}</span>
</code></pre></div>

<p>Then clean up after themselves using <code>free_cell</code> and/or <code>free_one_cell</code>, if neccessary!</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">feel_the_func</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// arity check</span>
    <span class="c1">// eval operands</span>
    <span class="c1">// argument type check</span>
    <span class="c1">// operate on inputs</span>
    <span class="c1">// clean up</span>
<span class="p">}</span>
</code></pre></div>

<p>and finally return a pointer to their computed value.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">feel_the_func</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// arity check</span>
    <span class="c1">// eval operands</span>
    <span class="c1">// argument type check</span>
    <span class="c1">// operate on inputs</span>
    <span class="c1">// clean up</span>
    <span class="c1">// return value</span>
<span class="p">}</span>
</code></pre></div>

<p>I&rsquo;ll start with <code>quote</code>, arguably the simplest function there is. It will
accept the first operand to the function:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">quote</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">operand</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// arity check</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">operand</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">NIL</span> <span class="o">||</span> <span class="n">operand</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">NIL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// operate on inputs</span>
    <span class="c1">// don&#39;t need to do anything for this</span>

    <span class="c1">// clean up</span>
    <span class="c1">// nothing here, either!</span>

    <span class="c1">// return value</span>
    <span class="k">return</span> <span class="n">operand</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Thats it! Now I have to register this label as a function in <code>apply</code>.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">apply</span><span class="p">(</span><span class="n">C</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">LABEL</span><span class="p">:</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="s">&quot;quote&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">C</span> <span class="o">*</span><span class="n">outcell</span> <span class="o">=</span> <span class="n">quote</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span> <span class="c1">// passing in the first operand instead of the operator</span>
                <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="c1">// free the operator!</span>
                <span class="k">return</span> <span class="n">outcell</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">apply</span><span class="p">(</span><span class="n">eval</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
        <span class="k">case</span> <span class="nl">NIL</span><span class="p">:</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>You can see that since I&rsquo;m passing the first operand into the function call, I
have to free the operator itself before passing back the return value. The
enclosing list cell is freed back up in <code>eval</code>:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">eval</span><span class="p">(</span><span class="n">C</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">LABEL</span><span class="p">:</span>
            <span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">LIST</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="n">C</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">apply</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
            <span class="n">out</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="c1">// here!</span>
            <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">NIL</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>So without comments, quote looks like this:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">quote</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">operand</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">NIL</span> <span class="o">||</span> <span class="n">operand</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">NIL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">operand</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Pretty simple! Now evalling:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="p">(</span><span class="n">quote</span> <span class="n">thingy</span><span class="p">)</span>                           <span class="o">=&gt;</span> <span class="n">thingy</span>
<span class="p">(</span><span class="n">quote</span> <span class="p">())</span>                               <span class="o">=&gt;</span> <span class="p">()</span>
<span class="p">(</span><span class="n">quote</span> <span class="p">(</span><span class="n">really</span> <span class="p">(</span><span class="n">anything</span> <span class="n">anywhere</span><span class="p">)))</span>     <span class="o">=&gt;</span> <span class="p">(</span><span class="n">really</span> <span class="p">(</span><span class="n">anything</span> <span class="n">anywhere</span><span class="p">))</span>
</code></pre></div>

<p><code>quote</code> is an <em>immensely</em> powerful part of lisp. The why behind that will
become apparent shortly!</p>

<hr>

<p>How about another!</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">car</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// arity check, must accept one thing only</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">operand</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">NIL</span> <span class="o">||</span> <span class="n">operand</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">NIL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// eval the operand</span>
    <span class="n">operand</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">operand</span><span class="p">);</span>

    <span class="c1">// operand type check: can only operate on lists</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">operand</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">LIST</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// clean up the cells we don&#39;t need, recursively, everything that is not</span>
    <span class="c1">// the first element in the list.</span>
    <span class="n">free_cell</span><span class="p">(</span><span class="n">operand</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>

    <span class="c1">// disconnect the first cell in the list from the rest of the list</span>
    <span class="n">C</span><span class="o">*</span> <span class="n">outcell</span> <span class="o">=</span> <span class="n">operand</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">list</span><span class="p">;</span>
    <span class="n">outcell</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nil</span><span class="p">;</span>

    <span class="c1">// free the enclosing list</span>
    <span class="n">free</span><span class="p">(</span><span class="n">operand</span><span class="p">);</span>

    <span class="c1">// return the newly liberated single cell</span>
    <span class="k">return</span> <span class="n">outcell</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>and register it in apply:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">apply</span><span class="p">(</span><span class="n">C</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">LABEL</span><span class="p">:</span> <span class="p">{</span>
            <span class="c1">// moving outcell declaration out here</span>
            <span class="n">C</span> <span class="o">*</span><span class="n">outcell</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="s">&quot;quote&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">outcell</span> <span class="o">=</span> <span class="n">quote</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="s">&quot;car&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">outcell</span> <span class="o">=</span> <span class="n">car</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">// c is always freed here</span>
            <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">outcell</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">apply</span><span class="p">(</span><span class="n">eval</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
        <span class="k">case</span> <span class="nl">NIL</span><span class="p">:</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Now we can call <code>car</code> on a list from within a Sild form and get back the first
element of that list.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="p">(</span><span class="n">car</span> <span class="p">(</span><span class="n">this</span> <span class="n">is</span> <span class="n">a</span> <span class="n">list</span><span class="p">))</span>
</code></pre></div>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">shell</span> <span class="n">returned</span> <span class="mi">1</span>
</code></pre></div>

<p>Hmm. Some better error messaging would be nice here&hellip; (I know I know! I&rsquo;ll get
to it!) but what is going on?</p>

<p>Well inside of <code>car</code>, the operand is being evaluated, which is what we want.
But when it tries to eval the list, it breaks, because <code>this</code> is not a
function (it is currently an unbound label).</p>

<p>This is why <code>quote</code> is so important!!</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="p">(</span><span class="n">car</span> <span class="p">(</span><span class="n">quote</span> <span class="p">(</span><span class="n">this</span> <span class="n">is</span> <span class="n">a</span> <span class="n">list</span><span class="p">)))</span>
</code></pre></div>

<p>returns</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">this</span>
</code></pre></div>

<p>A lot of lisp tutorials will say that the <code>quote</code> function &ldquo;stops evaluation.&rdquo;
Strictly speaking, this is true in practice, but I think it is misleading to
speak about the function as if it does something different than other forms&hellip;
it does not, <em>really</em>. <code>quote</code> forms are still evaluated, but the <em>operands</em> to them are
<em>not</em>. In this way, <code>quoted</code> cells <em>could</em> represent truly arbitrary data.</p>

<hr>

<p>How about <code>cdr</code>?</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">cdr</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// arity check</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">operand</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">NIL</span> <span class="o">||</span> <span class="n">operand</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">NIL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// eval the operand</span>
    <span class="n">operand</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">operand</span><span class="p">);</span>

    <span class="c1">// operand type check</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">operand</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">LIST</span> <span class="o">||</span> <span class="n">operand</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">NIL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">C</span> <span class="o">*</span><span class="n">garbage</span> <span class="o">=</span> <span class="n">operand</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">list</span><span class="p">;</span>
    <span class="n">operand</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">list</span> <span class="o">=</span> <span class="n">operand</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

    <span class="c1">// clean up the car cell we don&#39;t need, non-recursively.</span>
    <span class="n">free_one_cell</span><span class="p">(</span><span class="n">garbage</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">operand</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="p">(</span><span class="n">car</span> <span class="p">(</span><span class="n">car</span> <span class="p">(</span><span class="n">cdr</span> <span class="p">(</span><span class="n">cdr</span> <span class="p">(</span><span class="n">car</span> <span class="p">(</span><span class="n">cdr</span> <span class="p">(</span><span class="n">cdr</span>
    <span class="p">(</span><span class="n">quote</span>
        <span class="p">(((</span><span class="n">boop</span><span class="p">)</span> <span class="n">doop</span> <span class="p">(</span><span class="n">doop</span> <span class="n">doop</span> <span class="p">(</span><span class="n">woot</span><span class="o">!</span><span class="p">)))</span> <span class="n">waaaat</span><span class="p">)))))))))</span>
</code></pre></div>

<pre><code>woot!
</code></pre>

<hr>

<p>Ok, now for <code>cons</code>. Notice that in this case, none of the argument cells has to
be cleaned up, because the function is meant to return the same information,
but organized differently. It&rsquo;s to turn <code>a, (b c d)</code> into <code>(a b c d)</code>:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">cons</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span><span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// arity check</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">operand</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">NIL</span> <span class="o">||</span>
        <span class="n">operand</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">NIL</span> <span class="o">||</span>
        <span class="n">operand</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">NIL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// eval the operand</span>
    <span class="n">operand</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">operand</span><span class="p">);</span>

    <span class="c1">// operand type check</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">operand</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">LIST</span> <span class="o">||</span> <span class="n">operand</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">LIST</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// shuffling them around and returning the new list</span>
    <span class="n">C</span> <span class="o">*</span><span class="n">operand2</span> <span class="o">=</span> <span class="n">operand</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">operand</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">operand2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">list</span><span class="p">;</span>
    <span class="n">operand2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">list</span> <span class="o">=</span> <span class="n">operand</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">operand2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<hr>

<p>These are some pretty rudimentary operations in lisp! This is a good place to
stop and do some refactoring.</p>

<p>Here&rsquo;s what <code>apply</code> looks like now:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">apply</span><span class="p">(</span><span class="n">C</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">LABEL</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">C</span> <span class="o">*</span><span class="n">outcell</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="s">&quot;quote&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">outcell</span> <span class="o">=</span> <span class="n">quote</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="s">&quot;car&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">outcell</span> <span class="o">=</span> <span class="n">car</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="s">&quot;cdr&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">outcell</span> <span class="o">=</span> <span class="n">cdr</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="s">&quot;cons&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">outcell</span> <span class="o">=</span> <span class="n">cons</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">outcell</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">apply</span><span class="p">(</span><span class="n">eval</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
        <span class="k">case</span> <span class="nl">NIL</span><span class="p">:</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p><code>strcmp</code> is a real bottleneck, and hugely overkill for what it&rsquo;s doing here.
The function iterates through the entirety of at least one of the strings and
returns <code>0</code> if they are equal, <code>-1</code> if string one is &ldquo;less&rdquo; than string 2, and
<code>1</code> if string 2 is &ldquo;less&rdquo; than string 1. I don&rsquo;t have to go through the whole
string if at any point they differ, because I only care about whether or not
the are the same string completely. I can write a simple function that does
this a lot more efficiently for my use case.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="c1">// checks if two strings are equal, aborts at first sign they are not.</span>
<span class="kt">int</span> <span class="nf">scmp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str1</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// if ANY of the chars are different, or if the end of the second</span>
        <span class="c1">// string is reached before the first, abort and return false</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">str2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="n">str2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// if the end of the first string is reached and it is also the end of the</span>
    <span class="c1">// second, they are the same! return true.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">str2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// if there is more of the second string, return false.</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>And I can use this function in apply:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">apply</span><span class="p">(</span><span class="n">C</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">LABEL</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">C</span> <span class="o">*</span><span class="n">outcell</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">scmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="s">&quot;quote&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">outcell</span> <span class="o">=</span> <span class="n">quote</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="s">&quot;car&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">outcell</span> <span class="o">=</span> <span class="n">car</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="s">&quot;cdr&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">outcell</span> <span class="o">=</span> <span class="n">cdr</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">label</span><span class="p">,</span> <span class="s">&quot;cons&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">outcell</span> <span class="o">=</span> <span class="n">cons</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">outcell</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">apply</span><span class="p">(</span><span class="n">eval</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
        <span class="k">case</span> <span class="nl">NIL</span><span class="p">:</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>This allows me to dispense with the odd <code>!</code> boolean flip in the comparison, as
well. Faster and more readable ftw!</p>

<p><em>But wait, there&rsquo;s more!!</em></p>

<p>I can do away with <em>all</em> of the string comparisons for built in functions in
the application step! Next post I&rsquo;ll explain it!</p>

                </div>
            </article>
        </div>
    </body>
</html>
