<!DOCTYPE html>
<html lang="en-us">

    <head>
    <title>Mapping the Monado</title>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="icon" href="/images/jeff.ico" type="image/x-icon" />
    <link rel="stylesheet" href="/css/style.css">
    <link href="" rel="alternate feed" type="application/rss+xml" title="RSS Feed for blog.jfo.click" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>


    <body>
        <div id="content">
            <header class="site-header">
    <a href="https://blog.jfo.click/">archive</a> &mdash;
    <a href="https://blog.jfo.click/about">about</a> &mdash;
    <a href="https://blog.jfo.click/feed.xml">rss</a>
</header>

            <article>
                <p>
                    <h1>Mapping the Monado</h1>
                    <sub>September 15, 2017 </sub>
                <p>
                <div>
                    

<p>I have recently come into possession of a reasonably sound understanding of
monads. Tradition dictates that I now have an obligation to write a blog
post/tutorial/thing about them, wherein I attempt to gracefully share this
nascent knowledge through the judicious use of carefully chosen metaphors and
examples.  Legend has it that <a href="https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">I will inevitably
fail</a>
in this, and then be raked over the coals for my sins by both category
theorists and Haskellers alike. This isn&rsquo;t very appealing to me, but who am I
to challenge fate?</p>

<hr>

<p>I would not call this a tutorial, and though it might feel like it, at times,
I assume no real authority. I&rsquo;m just trying to explain some things I&rsquo;ve
just learned a bit about. Monads are particularly prickly both to explain and
understand, for a variety of reasons, but something that came up over and over
again while I was reading about them  was the necessity of &ldquo;developing an
intuition.&rdquo;</p>

<p>To that end, <a href="#ref">I&rsquo;ve included a lot of links I found helpful at the end of this
post</a>. Reading different takes on the subject can help to develop that
intuition in a way that no single tutorial ever could, and though
many posts like this start with something along the lines of &ldquo;I know the world
doesn&rsquo;t need another monad tutorial,&rdquo; I beg to differ. The only thing so far
that&rsquo;s made any of this click at all for me is the overlapping bits of all
these different posts and tutorials and such. It&rsquo;s a little like <a href="http://www.moishelettvin.com/2015/12/16/lowering-the-bar/">mapping the
potato!</a></p>

<p>So here&rsquo;s a little bit of the potato!</p>

<hr>

<p>Monads have a reputation. Why?</p>

<ol>
<li><p>The term is <a href="https://en.wikipedia.org/wiki/Monad">imprecise</a> across
disciplines, and even many professed experts
<a href="https://en.wikipedia.org/wiki/Talk:Monad_(functional_programming)/Archive_1">disagree</a>
on what constitutes a reasonable approach to explaining them in a programming
context.</p></li>

<li><p>&hellip;despite this, the term <em>is</em> precise within <a href="https://en.wikipedia.org/wiki/Monad_(category_theory)">category
theory</a>, which is a
fascinating but also particularly advanced and abstract branch of mathematics.</p></li>

<li><p>&hellip;and the term is <em>also</em> precise <a href="https://wiki.haskell.org/Monad">within
Haskell</a>, which is a <em>also</em> a fascinating
but particularly advanced and abstract programming language.</p></li>
</ol>

<p>Those two precisions seem to not always <em>quite</em> line up, exactly. Certainly,
the Haskell monads are derived from category theory, but the nomenclature is
dense on both sides and is difficult to parse out if you&rsquo;re new to both of
them.</p>

<p>Though I appreciate that a <em>complete</em> comprehension of monads and their
theoretical underpinnings may very well be predicated on becoming intimate with
category theory, I completely reject the assertion that a even a rudimentary and
useful understanding of monads and their applications <em>must</em> be preceded by that
study.</p>

<p>I&rsquo;m not alone in this. <a href="https://en.wikipedia.org/wiki/Philip_Wadler">Philip
Wadler</a>, in one of the <a href="https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/the-essence-of-functional-programming.pdf"><em>very first
papers</em></a>
ever written describing the practical uses of monads in functional programs,
said as much:</p>

<blockquote>
<p>The concept of a monad comes from category theory, but this paper assumes no
prior knowledge of such arcana. Rather, it is intended as a gentle introduction,
with an emphasis on why abstruse theory may be of interest to computing
scientists.</p>
</blockquote>

<p>Here&rsquo;s <a href="https://www.linkedin.com/in/brianbeckman/">Brian Beckman</a>
fullthroatedly <a href="https://www.youtube.com/watch?v=ZhuHCtR3xq8&amp;feature=youtu.be&amp;t=26m20s">making a similar
point.</a></p>

<blockquote>
<p>&hellip;and that&rsquo;s where we go into category theory&hellip; but you <em>don&rsquo;t need</em> to know
category theory, to be fully conversant, to be <em>fully fluent</em> in this language
of function composition. All you have to remember is the types need to line up.</p>
</blockquote>

<p>As I write this post, I know <em>very little</em> real category theory, and <em>very
little</em> Haskell&hellip; but I still have a working understanding of monads. This post
is as much a record of that understanding <em>at this time</em> as it is anything,
and that understanding will likely change and grow richer and more nuanced if and
when I <em>do</em> learn more about category theory and/or Haskell (as you might
expect, this process has piqued my interest in learning <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">more category theory</a>
and/or Haskell!)</p>

<p>I&rsquo;m not making an indictment of either of those in this post, either. I&rsquo;m just
saying it&rsquo;s not a <em>prerequisite</em> to developing an understanding and intuition
of what monads are and do. Beckman goes on&hellip;</p>

<blockquote>
<p>If you&rsquo;re going to nest function calls, the types have to line up. There&rsquo;s
nothing complicated about this you don&rsquo;t need to know category theory to&hellip; I mean
if you <em>want</em> to learn category theory to understand the full, flowering glory
of the consequences of this astonishing&hellip; you can and by all means, it will
only increase your richness, but you can now speak French in the world of monoidal
categories because you understand, that as long as the types line up, then
<strong>compositionality makes sense</strong>.</p>
</blockquote>

<hr>

<p>A monad is <em>three things</em> that, working together, satisfy <em>three
rules</em>, and that is what makes them, in aggregate, a monad.</p>

<p>The three things are:</p>

<h2 id="a-type-of-thing">a type of thing</h2>

<p>The structure doesn&rsquo;t matter, only that it satisfies a certain interface I&rsquo;ll
get into below.</p>

<h2 id="unit"><code>unit()</code></h2>

<p><code>unit</code> takes a value and returns a <em>new</em> something of a type that incorporates
that initial value.  It&rsquo;s <em>almost</em> just a constructor.</p>

<p>In javascript, I could use the <code>new</code> keyword for this. Again, it does not
matter what the structure of the returned thing is. I&rsquo;ll simply return an
object that has a <code>value</code> property.</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">const</span> <span class="nx">Thing</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="nx">value</span><span class="o">:</span> <span class="nx">x</span>
    <span class="p">};</span>
<span class="p">}</span></code></pre></div>
<p>For now, <code>unit</code> will simply be a wrapper around this constructor.</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">const</span> <span class="nx">unit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Thing</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>I will use only the <code>unit</code> function below, and it always means <code>new Thing()</code>.</p>

<h2 id="bind"><code>bind()</code></h2>

<p><em>This is not javascript&rsquo;s bind function.</em></p>

<p>Vanilla javascript doesn&rsquo;t have any typing to help here. I&rsquo;m going to use a
little <a href="https://www.typescriptlang.org/">Typescript</a> instead. You can just think
at it as javascript with type annotations!</p>

<p>Here is a function that takes a number and adds one to it and return a number!</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">const</span> <span class="nx">addOne</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="nx">number</span><span class="p">)</span> <span class="o">:</span> <span class="nx">number</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>
<p>What if I want to add one to a <code>Thing</code>?</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">mx</span> <span class="o">=</span> <span class="nx">unit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">addOne</span><span class="p">(</span><span class="nx">mx</span><span class="p">);</span></code></pre></div>
<p><code>mx</code> is a <code>Thing</code>, and <code>addOne</code> expects and <code>number</code>, so I get this compilation
error:</p>

<pre><code>../monad.ts (15,12): Argument of type 'Thing' is not assignable to parameter of type 'number'. (2345)
</code></pre>

<blockquote>
<p>In vanilla javascript, this <em>does work</em>. What it returns is much worse than
useless, though.</p>

<pre><code>[object Object]1
</code></pre>

<p>It casts my <code>Thing</code> to a string by calling <code>Thing.prototype.toString()</code>,
which returned <code>&quot;[object Object]&quot;</code>, then it &ldquo;added&rdquo; &ldquo;1&rdquo; to it by concatenating the
string <code>&quot;1&quot;</code> onto the end. Typescript catches this error.</p>
</blockquote>

<p>What I really wanted is a function <code>addOneToThing</code> that can add one to the
<code>value</code> of a <code>Thing</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">const</span> <span class="nx">addOneToThing</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">mx</span><span class="o">:</span> <span class="nx">Thing</span><span class="p">)</span> <span class="o">:</span> <span class="nx">Thing</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">unit</span><span class="p">(</span><span class="nx">mx</span><span class="p">.</span><span class="nx">value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>This function takes a <code>Thing</code> and returns a <em>new</em> <code>Thing</code>. And it does what I would
expect it to.</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">mx</span> <span class="o">=</span> <span class="nx">unit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">addOneToThing</span><span class="p">(</span><span class="nx">mx</span><span class="p">);</span></code></pre></div>
<pre><code>{ value: 2 }
</code></pre>

<p><code>addOneToThing</code> <em>knows</em> about <code>Thing</code>s. It knows how to get a value out of a
thing and it knows how to make a new one.</p>

<p><code>bind</code> is a function that knows how to <em>apply a function to an underlying type
contained inside of another type.</em></p>

<p>For this example, the underlying type is a <code>number</code>, and the another type is a
<code>Thing</code>, which is just an object with a <code>value</code> property that is a number!</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">const</span> <span class="nx">bind</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">fn</span><span class="o">:</span> <span class="nb">Function</span><span class="p">,</span> <span class="nx">mx</span><span class="o">:</span> <span class="nx">Thing</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fn</span><span class="p">(</span><span class="nx">mx</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p><code>bind</code> knows about <code>.value</code>, so <code>addOne</code> doesn&rsquo;t have to be <code>addOneToThing</code>
anymore. I can just use <code>bind</code>!</p>

<p>What do I get, then, if I <em>bind</em> <code>addOne</code> to a <code>Thing</code>?</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">bind</span><span class="p">(</span><span class="nx">addOne</span><span class="p">,</span> <span class="nx">unit</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span></code></pre></div>
<p>I get:</p>

<pre><code>2
</code></pre>

<p>This certainly works, but I am left with a <code>number</code> instead of a <code>Thing</code>. If I
try to bind another function to the return value, now:</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
    <span class="nx">bind</span><span class="p">(</span><span class="nx">addOne</span><span class="p">,</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">addOne</span><span class="p">,</span> <span class="nx">unit</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
<span class="p">);</span></code></pre></div>
<pre><code>NaN
</code></pre>

<blockquote>
<p>You might expect to see a type error like</p>

<pre><code>Argument of type 'number' is not assignable to parameter of type 'Thing'. (2345)
</code></pre>

<p>But <code>bind</code> is dynamically applying a function and can&rsquo;t be statically type checked here.</p>
</blockquote>

<p>If I wanted to <em>chain</em> these calls, then any function that is bound in this
fashion must accept a <em>bare</em> (underlying) value and <em>return a new <code>Thing</code></em>.</p>

<blockquote>
<p>&ldquo;If you&rsquo;re going to nest function calls, the types have to line up.&rdquo;</p>
</blockquote>

<p>You&rsquo;ll see this written a lot as <code>a -&gt; M b</code>, where <code>a</code> and <code>b</code> are, say,
numbers, and <code>M b</code> is, say, a number &ldquo;wrapped&rdquo; in some other structure or type.</p>

<p>I&rsquo;ll redefine <code>addOne</code> then, to do this, and add a <code>timesTwo</code> function to help
with the next example. The function signatures below amount to <code>a -&gt; M b</code> where
<code>M b</code> is a <code>Thing(number)</code> and <code>a</code> and <code>b</code> are <code>number</code>s.</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">const</span> <span class="nx">addOne</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="nx">number</span><span class="p">)</span> <span class="o">:</span> <span class="nx">Thing</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">unit</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">const</span> <span class="nx">timesTwo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="nx">number</span><span class="p">)</span> <span class="o">:</span> <span class="nx">Thing</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">unit</span><span class="p">(</span><span class="nx">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">};</span></code></pre></div>
<p>Now, if I</p>
<div class="highlight"><pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="nx">bind</span><span class="p">(</span><span class="nx">addOne</span><span class="p">,</span> <span class="nx">unit</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span></code></pre></div>
<p>I get a <code>Thing</code> back&hellip;</p>

<pre><code>Thing { value: 2 }
</code></pre>

<p>and if I</p>
<div class="highlight"><pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="nx">bind</span><span class="p">(</span><span class="nx">timesTwo</span><span class="p">,</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">addOne</span><span class="p">,</span> <span class="nx">unit</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span></code></pre></div>
<p>I <em>also</em> get a <code>Thing</code> back!</p>

<pre><code>Thing { value: 4 }
</code></pre>

<p>Interesting&hellip;</p>

<p>So, this is <em>all</em> that is needed to satisfy:</p>

<h1 id="the-three-laws">the three laws</h1>

<p>Described in terms of the preceding functions <code>unit</code> and <code>bind</code>, and using
<code>addOne</code> and <code>timesTwo</code> as arbitrary example functions that <em>happen</em> to have
this <code>a -&gt; M b</code> type signature, they are:</p>

<h2 id="left-identity">left identity</h2>

<p>Binding a function to a monad must result in the same output as calling the
bare function on the value(s) contained &ldquo;inside&rdquo; the monad.</p>

<p>so,</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">bind</span><span class="p">(</span><span class="nx">addOne</span><span class="p">,</span> <span class="nx">unit</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span></code></pre></div>
<p>must be equivalent to:</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">addone</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span></code></pre></div>
<p>They are! They both return:</p>

<pre><code>{ value: 2 }
</code></pre>

<h2 id="right-identity">right identity</h2>

<p>Binding a unit function to a monad must result in the same thing as simply
calling the unit function on a bare value.</p>

<p>So,</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">bind</span><span class="p">(</span><span class="nx">unit</span><span class="p">,</span> <span class="nx">unit</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span></code></pre></div>
<p>must be equivalent to:</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">unit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span></code></pre></div>
<p>They are! They both return:</p>

<pre><code>{ value: 1 }
</code></pre>

<h2 id="associativity">associativity</h2>

<p>Functions should be able to be composed together in any grouping and result in
the same ouput regardless of that grouping, assuming they are applied in the
same order.</p>

<p><code>compose</code> takes 2 functions and returns a <em>new function</em> that composes them
together. <code>compose(g, f)</code> then, returns a function that takes an input <code>mx</code>,
<code>bind</code>s <code>g</code> to it, and then <code>binds</code> <code>f</code> to <em>that</em>.</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">const</span> <span class="nx">compose</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">g</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">mx</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">bind</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">g</span><span class="p">,</span> <span class="nx">mx</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>So,</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">bind</span><span class="p">(</span><span class="nx">addOne</span><span class="p">,</span> <span class="nx">compose</span><span class="p">(</span><span class="nx">timesTwo</span><span class="p">,</span> <span class="nx">addOne</span><span class="p">)(</span><span class="nx">mx</span><span class="p">))</span></code></pre></div>
<p>must be equivalent to:</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">compose</span><span class="p">(</span><span class="nx">addOne</span><span class="p">,</span> <span class="nx">addOne</span><span class="p">)(</span><span class="nx">bind</span><span class="p">(</span><span class="nx">timesTwo</span><span class="p">,</span> <span class="nx">mx</span><span class="p">))</span></code></pre></div>
<p>They are! they both return</p>

<pre><code>{ value: 4 }
</code></pre>

<blockquote>
<p><a href="http://lambda-the-ultimate.org/node/2448">I briefly confused associativity with commutativity.</a></p>
</blockquote>

<h2 id="but-why">but&hellip; <em>why</em></h2>

<p>The usefulness of this construct is probably not readily apparent, but in
actual fact this is very powerful and can be used for many things, <em>especially</em>
in a purely functional context!</p>

<p>Last year, I wrote a completely pure, 100% pass by value functional lisp called
<a href="/sild-is-a-lisp-dialect">Sild</a>. There is not much to recommend it, really&hellip;
there are no types, not even <em>numbers</em>, just labels and lists. There is no
mutable state, there are no <code>let</code>s or <code>do</code>s either.</p>

<p>It&rsquo;s only quote, car, cdr, cons, eq, atom, cond, and lambda, and it has
define, but only at the top level, and it has display for printing to stdout,
and <em>that&rsquo;s all</em>.</p>

<p>Can I use monads in sild for anything useful? It turns out that I can!</p>

<p>I&rsquo;ll start by implementing the same thing from above, the <code>identity</code> monad.</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">define </span><span class="nv">unit</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">cons</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">()</span> <span class="p">)))</span></code></pre></div>
<p>I have no way of creating objects other than lists,, or types of any kind at
all, in Sild, but let&rsquo;s call a  &ldquo;<code>Thing</code>&rdquo; simply something that is wrapped in a
list. Remember, it doesn&rsquo;t really matter what the <em>structure of the type</em> is,
only that these particular interfaces are satisfied.</p>

<p><code>unit</code> is a function that will take something and wrap it in a list, then!</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nv">unit</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span></code></pre></div>
<pre><code>((a b c))
</code></pre>

<p>Remember that <code>bind</code> needs to know how to &ldquo;get at&rdquo; that internal value. In this
case, it&rsquo;s as simple as unwrapping that outer list by using <code>car</code> and then
applying the given function to it.</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">define </span><span class="nv">bind</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nv">f</span> <span class="nv">mx</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">f</span> <span class="p">(</span><span class="nv">car</span> <span class="nv">mx</span><span class="p">))))</span></code></pre></div>
<p>This is already <em>a</em> monad! I&rsquo;ve got a <em>type</em> of something, in this case denoted by
a doubly wrapped list. I have <code>unit</code> which takes a value and makes it into a
thing of that &ldquo;type&rdquo;, and I have <code>bind</code>, which knows how to &ldquo;unwrap&rdquo; the value
and apply a function to it!</p>

<p>Remember that the function it applies must have the type signature <code>a -&gt; M b</code>.
I don&rsquo;t have a type system to help here! But, any function I pass in needs to
take some value and return it as a &ldquo;<code>Thing</code>&rdquo;, in this case by wrapping it in a
list.</p>

<p>Here are three test functions that do that:</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">define </span><span class="nv">push_a</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">unit</span> <span class="p">(</span><span class="nv">cons</span> <span class="ss">&#39;a</span> <span class="nv">x</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">push_c</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">unit</span> <span class="p">(</span><span class="nv">cons</span> <span class="ss">&#39;c</span> <span class="nv">x</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">pop</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">unit</span> <span class="p">(</span><span class="nv">cdr</span> <span class="nv">x</span><span class="p">))))</span></code></pre></div>
<p>I&rsquo;ll also need <code>compose</code>, of course, to test for associativity. That looks just
like the js version:</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">define </span><span class="nv">compose</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nv">g</span> <span class="nv">f</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nv">m</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">bind</span> <span class="nv">f</span>
      <span class="p">(</span><span class="nv">bind</span> <span class="nv">g</span> <span class="nv">m</span><span class="p">)))))</span></code></pre></div>
<p>Does this already pass the tests? I don&rsquo;t have any list equality functions to
check with, but we can just look at the output!</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="c1">; this is a bare value to start with, it&#39;s just a list with a few symbols in it.</span>
<span class="p">(</span><span class="k">define </span><span class="nv">y</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="c1">; and here&#39;s a monadic version of that, created with `unit`!</span>
<span class="p">(</span><span class="k">define </span><span class="nv">My</span> <span class="p">(</span><span class="nv">unit</span> <span class="nv">y</span> <span class="p">))</span>

<span class="c1">; left identity</span>
<span class="p">(</span><span class="nv">display</span> <span class="p">(</span><span class="nv">bind</span> <span class="nv">pop</span> <span class="nv">My</span><span class="p">))</span>  <span class="c1">; ((b c))</span>
<span class="p">(</span><span class="nv">display</span> <span class="p">(</span><span class="nv">pop</span> <span class="nv">y</span><span class="p">))</span>        <span class="c1">; ((b c))</span>

<span class="c1">; right identity</span>
<span class="p">(</span><span class="nv">display</span> <span class="p">(</span><span class="nv">bind</span> <span class="nv">unit</span> <span class="nv">My</span><span class="p">))</span> <span class="c1">; ((a b c))</span>
<span class="p">(</span><span class="nv">display</span> <span class="nv">My</span><span class="p">)</span>             <span class="c1">; ((a b c))</span>

<span class="c1">; ; associativity</span>
<span class="p">(</span><span class="nv">display</span> <span class="p">(</span><span class="nv">bind</span> <span class="nv">push_c</span> <span class="p">((</span><span class="nv">compose</span> <span class="nv">push_a</span> <span class="nv">pop</span><span class="p">)</span> <span class="nv">My</span><span class="p">)))</span> <span class="c1">; ((c a b c))</span>
<span class="p">(</span><span class="nv">display</span> <span class="p">((</span><span class="nv">compose</span> <span class="nv">pop</span> <span class="nv">push_c</span><span class="p">)</span> <span class="p">(</span><span class="nv">bind</span> <span class="nv">push_a</span> <span class="nv">My</span><span class="p">)))</span> <span class="c1">; ((c a b c))</span></code></pre></div>
<p>This is the identity monad!</p>

<h2 id="a-digression-monads-are-like-functions">A digression Monads are <em>&ldquo;like&rdquo;</em> functions</h2>

<p>Monads, like functions, are an <em>abstraction</em>. Functions can be thought of in
metaphorical terms&hellip; a black box, a machine with inputs and outputs, these are
intuitively correct but insufficient descriptions of what a function <em>is</em>.
Monads can also be thought of in metaphorical terms. A monad is a container, a
monad is a burrito, a bucket, or a package&hellip; more abstractly (and accurately,
but not completely) as a sort of composition of functions on types&hellip; likewise,
these metaphors can be intuitively correct but insufficient. Consider much of
the language I use above&hellip; &ldquo;get at that internal value&rdquo; accurately describes
what &ldquo;bind&rdquo; is doing for me right now, <em>but</em> it&rsquo;s not at all sufficient to
describe the <em>general</em> case of what makes something monadic, just a <em>common</em>
and easy to understand one. This is only part of the potato, is what I&rsquo;m saying.</p>

<p>Simlarly, monads are <em>not</em> the structure of type <code>Thing</code>, and <code>Thing</code> alone,
though acting as a container, is <em>not</em> a monad.  <code>Thing</code> <em>plus</em> the <code>unit</code> and
<code>bind</code> procedures made available to work with and around it <em>together</em> make up
the monad.</p>

<p>You might ask, what does this make <em>possible</em>, then? Well, what do <em>functions</em>
make possible, exactly? Does that question even really make <em>sense</em>? Is it
specific enough to have any answer besides &ldquo;a lot of things&rdquo;?</p>

<p>It doesn&rsquo;t really matter how you architect these procedures and types, what
matters is the availability of these rudimentary operations and their ability to
pass those three tests: left identity, right identity, and associativity. That is <em>all</em>
that matters in terms of defining a monad. To prove this, here&rsquo;s another
Identity monad implemented in a more object oriented way, This time using PHP.</p>

<p>First, I&rsquo;ll define an interface that any monadic class will need to implement.</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?</span>
<span class="k">interface</span> <span class="nx">Monad</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="o"></span><span class="nf">unit</span><span class="p">(</span><span class="nv">$x</span><span class="p">);</span>
    <span class="k">public</span> <span class="k">function</span> <span class="o"></span><span class="nf">bind</span><span class="p">(</span><span class="nx">callable</span> <span class="nv">$fn</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>Now, I&rsquo;ll make one!</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?</span>

<span class="k">class</span> <span class="nc">ID</span> <span class="k">implements</span> <span class="nx">Monad</span> <span class="p">{</span>

    <span class="k">private</span> <span class="nv">$value</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">function</span> <span class="o"></span><span class="fm">__construct</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">value</span> <span class="o">=</span> <span class="nv">$n</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="o"></span><span class="nf">unit</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">ID</span><span class="p">(</span><span class="nv">$x</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="o"></span><span class="nf">bind</span><span class="p">(</span><span class="nx">callable</span> <span class="nv">$fn</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$fn</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="o"></span><span class="nf">compose</span><span class="p">(</span><span class="nx">callable</span> <span class="nv">$g</span><span class="p">,</span> <span class="nx">callable</span> <span class="nv">$f</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$g</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">value</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">bind</span><span class="p">(</span><span class="nv">$f</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>Here are two functions that I can pass to <code>bind</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?</span>

<span class="nv">$increment</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">ID</span><span class="o">::</span><span class="na">unit</span><span class="p">(</span><span class="nv">$n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="p">};</span>
<span class="nv">$times2</span>    <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">ID</span><span class="o">::</span><span class="na">unit</span><span class="p">(</span><span class="nv">$n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span> <span class="p">};</span></code></pre></div>
<p>Does this pass those tests?</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?</span>

<span class="c1"># left identity
</span><span class="c1"></span><span class="nx">ID</span><span class="o">::</span><span class="na">unit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">bind</span><span class="p">(</span><span class="nv">$increment</span><span class="p">)</span> <span class="o">==</span> <span class="nv">$increment</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># right identity
</span><span class="c1"></span><span class="nx">ID</span><span class="o">::</span><span class="na">unit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">bind</span><span class="p">(</span><span class="s2">&#34;ID::unit&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="nx">ID</span><span class="o">::</span><span class="na">unit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># associativity identity
</span><span class="c1"></span><span class="nx">ID</span><span class="o">::</span><span class="na">unit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">compose</span><span class="p">(</span><span class="nv">$increment</span><span class="p">,</span> <span class="nv">$times2</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">bind</span><span class="p">(</span><span class="nv">$increment</span><span class="p">)</span> <span class="o">==</span>
<span class="nx">ID</span><span class="o">::</span><span class="na">unit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">bind</span><span class="p">(</span><span class="nv">$increment</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">compose</span><span class="p">(</span><span class="nv">$times2</span><span class="p">,</span> <span class="nv">$increment</span><span class="p">);</span></code></pre></div>
<p>All of these are:</p>

<pre><code>bool(true)
</code></pre>

<p>Notice something important, here&hellip; those <code>bind</code>s are <em>not returning self</em>.
There&rsquo;s no mutation happening to the original object, it&rsquo;s a completely new
<code>ID</code>, each and every time. I&rsquo;m not going to say that&rsquo;s the most efficient
pattern in terms of memory use, but languages designed for purely functional
calculations employ techniques to mitigate and <a href="http://okasaki.blogspot.dk/2008/02/ten-years-of-purely-functional-data.html">abstract this
away</a></p>

<h2 id="back-to-sild-and-something-actually-useful">Back to Sild and something actually useful&hellip;</h2>

<p>How can I keep track of all the functions I&rsquo;ve run on an object? In a stateful
language, this is pretty easy. Here&rsquo;s one way to do so in some Ruby:</p>
<div class="highlight"><pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Whatever</span>
    <span class="kp">attr_reader</span> <span class="ss">:history</span><span class="p">,</span> <span class="ss">:value</span>

    <span class="k">def</span> <span class="nc"></span><span class="o"></span><span class="nf">initialize</span>
        <span class="vi">@history</span> <span class="o">=</span> <span class="o">[]</span>
        <span class="vi">@value</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="o"></span><span class="k">end</span>

    <span class="k">def</span> <span class="nc"></span><span class="o"></span><span class="nf">inc</span>
        <span class="vi">@history</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;inc&#39;</span>
        <span class="vi">@value</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="o"></span><span class="nb">self</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nc"></span><span class="o"></span><span class="nf">dec</span>
        <span class="vi">@history</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;dec&#39;</span>
        <span class="vi">@value</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="o"></span><span class="nb">self</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="n">x</span> <span class="o">=</span> <span class="no">Whatever</span><span class="o">.</span><span class="n">new</span>
<span class="n">x</span><span class="o">.</span><span class="n">inc</span><span class="o">.</span><span class="n">inc</span><span class="o">.</span><span class="n">dec</span><span class="o">.</span><span class="n">inc</span><span class="o">.</span><span class="n">inc</span><span class="o">.</span><span class="n">inc</span><span class="o">.</span><span class="n">dec</span><span class="o">.</span><span class="n">dec</span><span class="o">.</span><span class="n">dec</span>

<span class="nb">puts</span> <span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="c1"># 1</span>
<span class="nb">puts</span> <span class="n">x</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&#34;, &#34;</span><span class="p">)</span> <span class="c1"># inc, inc, dec, inc, inc, inc, dec, dec, dec</span></code></pre></div>
<p>I&rsquo;m sure that could be metaprogrammed and monkeypatched into Object if you
wanted to debug <em>everything</em> run on <em>everything</em>.</p>

<p>But, how could I <em>possibly</em> do this in a pure language, with no mutability or
global state, and no side effects? It can be done!</p>

<p>I&rsquo;m going to implement a <a href="http://adit.io/posts/2013-06-10-three-useful-monads.html#the-writer-monad">writer
monad</a>
that will let me keep a log of all the functions I&rsquo;ve run, in Sild.</p>

<p>First, I&rsquo;ll define some aliases I like to use:</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">define </span><span class="nv">def</span> <span class="nv">define</span><span class="p">)</span>
<span class="p">(</span><span class="nv">def</span> <span class="nv">λ</span> <span class="nv">lambda</span><span class="p">)</span></code></pre></div>
<p>Sild is not especially smart, but you <em>can</em> use arbitrary unicode like <code>λ</code> and
redefine basic language keywords, which is nice.</p>

<p>I&rsquo;ll also define a few old fashioned lisp functions.</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nv">def</span> <span class="nv">cadr</span> <span class="p">(</span><span class="nv">λ</span> <span class="p">(</span><span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nv">car</span> <span class="p">(</span><span class="nv">cdr</span> <span class="nv">l</span><span class="p">))))</span>
<span class="p">(</span><span class="nv">def</span> <span class="nv">caadr</span> <span class="p">(</span><span class="nv">λ</span> <span class="p">(</span><span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nv">car</span> <span class="p">(</span><span class="nv">car</span> <span class="p">(</span><span class="nv">cdr</span> <span class="nv">l</span><span class="p">)))))</span></code></pre></div>
<p>I&rsquo;ll also need a couple of utility functions&hellip;</p>

<p><code>reverse</code> will reverse a list.</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nv">def</span> <span class="nv">revinner</span>
 <span class="p">(</span><span class="nv">λ</span> <span class="p">(</span><span class="nv">l</span> <span class="nv">acc</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="nv">l</span> <span class="p">(</span><span class="nv">revinner</span> <span class="p">(</span><span class="nv">cdr</span> <span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nv">cons</span> <span class="p">(</span><span class="nv">car</span> <span class="nv">l</span><span class="p">)</span> <span class="nv">acc</span><span class="p">))</span>
        <span class="nv">acc</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">def</span> <span class="nv">reverse</span> <span class="p">(</span><span class="nv">λ</span> <span class="p">(</span><span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nv">revinner</span> <span class="nv">l</span> <span class="o">&#39;</span><span class="p">())))</span></code></pre></div>
<p><code>unshift</code> will &ldquo;push&rdquo; something on to the <em>end</em> of a list. It&rsquo;s the opposite of
<code>cons</code> and <code>push</code>.  <a href="http://www.perlmonks.org/?node_id=613124">Here read this!</a></p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nv">def</span> <span class="nv">unshift</span>
  <span class="p">(</span><span class="nv">λ</span> <span class="p">(</span><span class="nv">el</span> <span class="nv">l</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">reverse</span> <span class="p">(</span><span class="nv">cons</span> <span class="nv">el</span> <span class="p">(</span><span class="nv">reverse</span> <span class="nv">l</span><span class="p">)))))</span></code></pre></div>
<p>Ok, with these useful extras out of the way, let&rsquo;s get to the meat of things.</p>

<p>Here&rsquo;s the unit function. This monad will have the form:</p>

<pre><code>(() ())
</code></pre>

<p>&hellip;that is to say, it must be a list with two lists inside of it.
The first will be the value, the second will be the record (history) of all the
procedures that were bound to the monad. <code>unit</code> then will take a value (a
list), and &lsquo;wrap&rsquo; it into a monad with a blank history.</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nv">def</span> <span class="nv">unit</span>
  <span class="p">(</span><span class="nv">λ</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">cons</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">(()))))</span></code></pre></div>
<p>I&rsquo;ll have a constructor, that simply takes two lists and wraps them up.</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nv">def</span> <span class="nv">constructor</span>
  <span class="p">(</span><span class="nv">λ</span> <span class="p">(</span><span class="nv">value</span> <span class="nv">history</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">cons</span> <span class="nv">value</span> <span class="p">(</span><span class="nv">cons</span> <span class="nv">history</span> <span class="o">&#39;</span><span class="p">()))))</span></code></pre></div>
<p>And I&rsquo;ll define a few aliases to make it clearer what I&rsquo;m doing to <code>Thing</code>s</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="c1">; some aliases to make usage clearer when applied to `Thing`s.</span>
<span class="p">(</span><span class="nv">def</span> <span class="nv">get-val</span> <span class="nv">car</span><span class="p">)</span>
<span class="p">(</span><span class="nv">def</span> <span class="nv">get-hist</span> <span class="nv">cadr</span><span class="p">)</span>
<span class="p">(</span><span class="nv">def</span> <span class="nv">get-most-recent-hist</span> <span class="nv">caadr</span><span class="p">)</span></code></pre></div>
<p>Here&rsquo;s a function that writes a new element to a history and returns a new
Thing with that new history, leaving the value unchanged.</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="c1">; takes a symbol `sym` and a monad `Mx` and returns a new monad with the symbol</span>
<span class="c1">; appended to its history list</span>
<span class="p">(</span><span class="nv">def</span> <span class="nv">write-to-hist</span>
  <span class="p">(</span><span class="nv">λ</span> <span class="p">(</span><span class="nv">sym</span> <span class="nv">Mx</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">constructor</span> <span class="p">(</span><span class="nv">get-val</span> <span class="nv">Mx</span><span class="p">)</span>
                 <span class="p">(</span><span class="nv">unshift</span> <span class="nv">sym</span> <span class="p">(</span><span class="nv">get-hist</span> <span class="nv">Mx</span><span class="p">)))))</span></code></pre></div>
<p>Next, I&rsquo;ll need this function that takes two <code>Thing</code>s, an old one and a new one.
It merges the histories, and returns a new <code>Thing</code> with the new value and the
merged histories.</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="c1">; takes two monads, an old one and a new one. Combines the new&#39;s value with the</span>
<span class="c1">; old&#39;s history while appending the new&#39;s most recent history entry.</span>
<span class="p">(</span><span class="nv">def</span> <span class="nv">combine-hist</span>
  <span class="p">(</span><span class="nv">λ</span> <span class="p">(</span><span class="nv">m-old</span> <span class="nv">m-new</span><span class="p">)</span>
<span class="c1">; if both histories are equal, it&#39;s empty. We don&#39;t need to merge anything,</span>
<span class="c1">; just return the new one:</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">(</span><span class="nv">eq</span> <span class="p">(</span><span class="nv">get-hist</span> <span class="nv">m-old</span><span class="p">)</span> <span class="p">(</span><span class="nv">get-hist</span> <span class="nv">m-new</span><span class="p">))</span> <span class="nv">m-new</span>
<span class="c1">; otherwise, write the most recent history entry from the new to the old and</span>
<span class="c1">; return a new monad made of the value of the new and the merged histories</span>
              <span class="p">(</span><span class="nv">constructor</span>
                <span class="p">(</span><span class="nv">get-val</span> <span class="nv">m-new</span><span class="p">)</span>
                <span class="p">(</span><span class="nv">get-hist</span> <span class="p">(</span><span class="nv">write-to-hist</span> <span class="p">(</span><span class="nv">get-most-recent-hist</span> <span class="nv">m-new</span><span class="p">)</span>
                                         <span class="nv">m-old</span><span class="p">))))))</span></code></pre></div>
<p>It&rsquo;s our friend, bind! in this case, we apply the function with signature <code>a -&gt;
M b</code> to the extracted value, and combine histories, and we&rsquo;re done!</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nv">def</span> <span class="nv">bind</span>
  <span class="p">(</span><span class="nv">λ</span> <span class="p">(</span><span class="nv">f</span> <span class="nv">Mx</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">combine-hist</span> <span class="nv">Mx</span>
                  <span class="p">(</span><span class="nv">f</span> <span class="p">(</span><span class="nv">get-val</span> <span class="nv">Mx</span><span class="p">)))))</span></code></pre></div>
<p>It might seem like not much is happening here- to be fair, I&rsquo;ve hidden quite
a bit of complexity in that <code>combine-history</code> function. But this is truly
&ldquo;where the magic happens.&rdquo; Because <code>bind</code> &ldquo;knows&rdquo; so much about the structure
of this monad, and has references available to both the old and new state of
the monads as they are being operated on, I can <em>do stuff</em> here. This writer
monad is a type of &ldquo;state&rdquo; monad because it &ldquo;persists&rdquo; state throughout these
function calls. <code>bind</code> is the place and the mechanism for that persistence. But
this is <em>only one use</em> of monads, and a relatively simple one at that.</p>

<p>A salient take home point: <code>bind</code>&rsquo;s implementation for any particular monad is
where a lot of the complexity is both implemented and hidden away.</p>

<p>Now, I&rsquo;ll also need some functions of the form <code>a -&gt; M b</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="c1">; takes a datum to push into something and a name for the function to be</span>
<span class="c1">; recorded into history as and returns a function that pushes into a value and</span>
<span class="c1">; returns a monad</span>
<span class="p">(</span><span class="nv">def</span> <span class="nv">makepusher</span>
  <span class="p">(</span><span class="nv">λ</span> <span class="p">(</span><span class="nv">datum</span> <span class="nv">name</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">λ</span> <span class="p">(</span><span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nv">write-to-hist</span> <span class="nv">name</span> <span class="p">(</span><span class="nv">unit</span> <span class="p">(</span><span class="nv">cons</span> <span class="nv">datum</span> <span class="nv">l</span><span class="p">))))))</span>

<span class="p">(</span><span class="nv">def</span> <span class="nv">push-a</span> <span class="p">(</span><span class="nv">makepusher</span> <span class="ss">&#39;a</span> <span class="ss">&#39;push-a</span><span class="p">))</span>
<span class="p">(</span><span class="nv">def</span> <span class="nv">push-b</span> <span class="p">(</span><span class="nv">makepusher</span> <span class="ss">&#39;b</span> <span class="ss">&#39;push-b</span><span class="p">))</span>
<span class="p">(</span><span class="nv">def</span> <span class="nv">push-c</span> <span class="p">(</span><span class="nv">makepusher</span> <span class="ss">&#39;c</span> <span class="ss">&#39;push-c</span><span class="p">))</span>
<span class="c1">; this will break if the monad&#39;s value list is empty! caveat lisper</span>
<span class="p">(</span><span class="nv">def</span> <span class="nv">pop</span>    <span class="p">(</span><span class="nv">λ</span> <span class="p">(</span><span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nv">write-to-hist</span> <span class="ss">&#39;pop</span> <span class="p">(</span><span class="nv">unit</span> <span class="p">(</span><span class="nv">cdr</span> <span class="nv">l</span><span class="p">)))))</span></code></pre></div>
<p>And finally, compose, which looks and acts just like the js example.</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nv">def</span> <span class="nv">compose</span>
  <span class="p">(</span><span class="nv">λ</span> <span class="p">(</span><span class="nv">g</span> <span class="nv">f</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">λ</span> <span class="p">(</span><span class="nv">m</span><span class="p">)</span> <span class="p">(</span><span class="nv">bind</span> <span class="nv">f</span> <span class="p">(</span><span class="nv">bind</span> <span class="nv">g</span> <span class="nv">m</span><span class="p">)))))</span></code></pre></div>
<p>With all of this out of the way, what do we get? Does this pass those three tests?</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="c1">; an initial value state to play with</span>
<span class="p">(</span><span class="nv">def</span> <span class="nv">y</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="c1">; an initial monad with that initial value state to play with</span>
<span class="p">(</span><span class="nv">def</span> <span class="nv">My</span> <span class="p">(</span><span class="nv">unit</span> <span class="nv">y</span><span class="p">))</span>

<span class="c1">; left identity</span>
<span class="p">(</span><span class="nv">display</span> <span class="p">(</span><span class="nv">bind</span> <span class="nv">pop</span> <span class="nv">My</span><span class="p">))</span>  <span class="c1">; ((b c) (pop))</span>
<span class="p">(</span><span class="nv">display</span> <span class="p">(</span><span class="nv">pop</span> <span class="nv">y</span><span class="p">))</span>        <span class="c1">; ((b c) (pop))</span>

<span class="c1">; right identity</span>
<span class="p">(</span><span class="nv">display</span> <span class="nv">My</span><span class="p">)</span>             <span class="c1">; ((a b c) ())</span>
<span class="p">(</span><span class="nv">display</span> <span class="p">(</span><span class="nv">bind</span> <span class="nv">unit</span> <span class="nv">My</span><span class="p">))</span> <span class="c1">; ((a b c) ())</span>

<span class="c1">; associativity</span>
<span class="p">(</span><span class="nv">display</span> <span class="p">(</span><span class="nv">bind</span> <span class="nv">push-c</span> <span class="p">((</span><span class="nv">compose</span> <span class="nv">push-a</span> <span class="nv">pop</span><span class="p">)</span> <span class="nv">My</span><span class="p">)))</span> <span class="c1">; ((c a b c) (push-a pop push-c))</span>
<span class="p">(</span><span class="nv">display</span> <span class="p">((</span><span class="nv">compose</span> <span class="nv">pop</span> <span class="nv">push-c</span><span class="p">)</span> <span class="p">(</span><span class="nv">bind</span> <span class="nv">push-a</span> <span class="nv">My</span><span class="p">)))</span> <span class="c1">; ((c a b c) (push-a pop push-c))</span></code></pre></div>
<p>Indeed it does. This is a monad! And look here,</p>
<div class="highlight"><pre class="chroma"><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nv">display</span> <span class="p">(</span><span class="nv">bind</span> <span class="nv">push-c</span>
          <span class="p">(</span><span class="nv">bind</span> <span class="nv">pop</span>
           <span class="p">(</span><span class="nv">bind</span> <span class="nv">pop</span>
            <span class="p">(</span><span class="nv">bind</span> <span class="nv">push-a</span>
             <span class="p">(</span><span class="nv">bind</span> <span class="nv">push-b</span>
              <span class="p">(</span><span class="nv">bind</span> <span class="nv">push-c</span>
               <span class="p">(</span><span class="nv">bind</span> <span class="nv">pop</span>
                <span class="p">(</span><span class="nv">bind</span> <span class="nv">pop</span> <span class="nv">My</span><span class="p">)))))))))</span>
<span class="c1">; ((c c c) (pop pop push-c push-b push-a pop pop push-c))</span></code></pre></div>
<p>This monad has a &ldquo;memory&rdquo;, a history of everything that&rsquo;s been bound to it! That is useful!</p>

<p>Thanks to Gabe Herrera, Adit Bhargava, Vaibhav Sagar, Veit Heller, Julia Evans, and Alan O&rsquo;Donnell for discussing drafts of this post with me.</p>

<p><div id="ref"></p>

<h2 id="references">References</h2>

<p>Here are a bunch of things I read or watched to do this post. In no particular
order. I&rsquo;d recommend reading as many things as you can get your hands on to get
different perspectives and facets presented in as many ways as possible.</p>

<ul>
<li><a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia</a></li>
<li><a href="https://curiosity-driven.org/monads-in-javascript">Monads in JavaScript</a></li>
<li><a href="http://homepages.inf.ed.ac.uk/wadler/topics/monads.html">Monads, Arrows, and Idioms</a>, a collection of papers by Philip Wadler</li>
<li><a href="http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html">You Could Have Invented Monads! (And Maybe You Already Have.)</a> by Dan Piponi</li>
<li><a href="https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">Abstraction, intuition, and the “monad tutorial fallacy”</a> by Brent Yorgey</li>
<li><a href="https://two-wrongs.com/the-what-are-monads-fallacy">The &ldquo;What Are Monads?&rdquo; Fallacy</a></li>
<li><a href="https://www.youtube.com/watch?v=ZhuHCtR3xq8">Don&rsquo;t fear the Monad</a> by Brian Beckman</li>
<li><a href="http://vaibhavsagar.com/blog/2016/10/12/monad-anti-tutorial/">Monad Anti-tutorial</a> by Vaibhav Sagar</li>
<li><a href="http://goodmath.scientopia.org/2012/08/19/monads-and-programming/">Monads and Programming</a> by Mark Chu-Carroll</li>
<li><a href="https://miklos-martin.github.io/learn/fp/2016/03/10/monad-laws-for-regular-developers.html">Monad laws for regular developers</a> by Miklos Martin</li>
<li><a href="http://lambda-the-ultimate.org/node/2448">Question about the Monad associativity laws</a></li>
<li><a href="https://web.archive.org/web/20050204001716/http://www.nomaware.com/monads/html/index.html">All About Monads</a></li>
<li><a href="http://www.ccs.neu.edu/home/dherman/browse/shared/notes/monads/monads-for-schemers.txt">A Schemer&rsquo;s Introduction to Monads</a> by Dave Herman</li>
<li><a href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass">The Functor Typeclass</a> from LYAHFGG</li>
<li><a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids">Functors, Applicative Functors and Monoids</a> from LYAHFGG</li>
<li><a href="https://wiki.haskell.org/Monad_laws">Monad Laws</a> from the Haskell wiki</li>
<li><a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, And Monads In Pictures</a> by Aditya Bhargava</li>
<li><a href="http://adit.io/posts/2013-06-10-three-useful-monads.html">Three Useful Monads</a> by Aditya Bhargava</li>
<li><a href="https://stackoverflow.com/questions/3433608/explanation-of-monad-laws">Explanation of Monad laws</a> from SO</li>
<li><a href="https://medium.com/@dtinth/what-is-a-functor-dcf510b098b6">What is a functor?</a> by Thai Pangsakulyanont</li>
<li><a href="http://learnyouahaskell.com/a-fistful-of-monads">A Fistful of Monads</a> from LYAHFGG</li>
<li><a href="https://medium.com/@tzehsiang/javascript-functor-applicative-monads-in-pictures-b567c6415221">Javascript Functor, Applicative, Monads in pictures</a> &lsquo;by&rsquo; Tze-Hsiang Lin</li>
<li><a href="http://slides.com/julientournay/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-what-s-the-problem/#/">A monad is just a monoid in the category of endofunctors. what&rsquo;s the problem?</a> by Julien Tournay</li>
<li><a href="https://ericlippert.com/2013/02/21/monads-part-one/#more-461">Monads, part one</a> by Eric Lippert (this whole series is excellent)</li>
<li><a href="http://etymon.blogspot.dk/2006/09/monad-laws.html">The Monad Laws</a> by Andrae Muys</li>
<li><a href="http://blog.ssanj.net/posts/2017-06-07-composing-monadic-functions-with-kleisli-arrows.html">Composing Monadic Functions with Kleisli Arrows</a></li>
<li><a href="https://jrsinclair.com/articles/2016/marvellously-mysterious-javascript-maybe-monad/">The Marvellously Mysterious Javascript Maybe Monad</a> by James Sinclair</li>
<li><a href="http://blog.klipse.tech/javascript/2016/08/31/monads-javascript.html">Functional programming: Monads made clear - in javascript</a> by Yehonathan Sharvit</li>
<li><a href="https://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/">Translation from Haskell to JavaScript of selected portions of the best introduction to monads I’ve ever read</a> by James Coglan</li>
<li><a href="http://www.lispcast.com/monads-and-objects">Monads and Objects</a> on LispCast</li>
<li><a href="https://karma-engineering.com/lab/wiki/Monads2">A grumpy rant that makes some good points</a></li>
</ul>

                </div>
            </article>
        </div>
    </body>
</html>
