<!DOCTYPE html>
<html lang="en-us">

    <head>
    <title>Advent of Learning About MD5 and OpenCL</title>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="icon" href="http://blog.jfo.clickimages/jeff.ico" type="image/x-icon" />
    <style type="text/css">
        @font-face {
    font-family: "etbook";
    src: url("http://blog.jfo.clickcss/et-book.woff") format('woff');
}


    </style>
    <link rel="stylesheet" href="http://blog.jfo.clickcss/style.css">
    <link rel="stylesheet" href="http://blog.jfo.clickcss/solarized-dark.css">
    <link href="" rel="alternate feed" type="application/rss+xml" title="RSS Feed for blog.jfo.click" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>


    <body>
        <div id="content">
            <header class="site-header">
    <a href="http://blog.jfo.click"><h4>archive</h4></a> &mdash;
    <a href="http://blog.jfo.clickabout"><h4>about</h4></a> &mdash;
    <a href="http://blog.jfo.clickfeed.xml"><h4>rss</h4></a>
</header>

            <article>
                <h1>Advent of Learning About MD5 and OpenCL</h1>
                <sub>December 28, 2016 </sub>
                <div>
                    

<p>So Hi, hello. <a href="/adventure-of-advent-of-code">Last post</a> I was talking about <a href="http://adventofcode.com/">Advent of
Code</a> and how it can help you discover new things and
ideas to learn about and also rabbit holes to go down. This post is about one
of those rabbit holes! It&rsquo;s a really deep one, too. I got nerdsniped on day 5
and I totally couldn&rsquo;t let it go.</p>

<p>This post got kind of ridiculously long. I&rsquo;m sorry. But this snipe definitely
took me for a ride. I hope it&rsquo;s interesting!</p>

<div id="toc"></div>

<h1 id="table-of-contents">Table of Contents</h1>

<ul>
<li><a href="#chess">How about a nice game of chess?</a></li>
<li><a href="#expense">This is Expensive</a></li>
<li><a href="#hole">Down the Hole</a></li>
<li><a href="#own">My own md5 function</a></li>
<li><a href="#padding">Padding</a></li>
<li><a href="#time">Time to actually process the hash</a></li>
<li><a href="#output">Output</a></li>
<li><a href="#quite">I am quite sure my homegrown hashing function will outperform Ruby&rsquo;s built in version</a></li>
<li><a href="#c">Let&rsquo;s C</a></li>
<li><a href="#opencl">Act III: OpenCL</a></li>
<li><a href="#crackin">Crackin&rsquo;</a></li>
<li><a href="#coda">Advent of Coda</a></li>
</ul>

<p><sub><a href='#toc'>toc</a></sub>
<div id="chess"></div></p>

<h1 id="how-about-a-nice-game-of-chess">How about a nice game of chess?</h1>

<p>Day 5 this year asks us to calculate an 8 digit code based on the <a href="https://en.wikipedia.org/wiki/MD5">md5
digest</a> of a user-specific input
concatenated with the string representations of incrementing numbers.</p>

<p><img src="https://pbs.twimg.com/media/CzwETWbUsAALRtW.jpg" alt="img" /></p>

<blockquote>
<p><sub>
<a href="https://twitter.com/jon_bottarini/status/809526790494375937">Source</a>, sort of,
not that it matters, not that anything matters, since that&rsquo;s not even the
source and the real source is
<a href="http://poorlydrawnlines.com/comic/a-message/">this</a> and copyright law is broken
and we live in a creative post scarcity society.
<a href="https://media.giphy.com/media/Wgx6zPreg4aac/giphy.gif" ><img height=20 style="display:inline;" src="https://imgflip.com/s/meme/But-Thats-None-Of-My-Business.jpg" /></a>
</sub></p>
</blockquote>

<p><a href="http://adventofcode.com/2016/day/5">You should go read the question here!</a></p>

<blockquote>
<p>Spoiler alert, etc, cause I&rsquo;m about to just explain how I did this one so if
you want to solve it yourself you should go do that first.</p>
</blockquote>

<p>My door input was <code>abbhdwsy</code>. With just two small lines, I can compute the MD5
hash for that basic input like this using Ruby&rsquo;s built in library method:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="nb">require</span> <span class="s1">&#39;digest&#39;</span>
<span class="nb">puts</span> <span class="no">Digest</span><span class="o">::</span><span class="no">MD5</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(</span><span class="s2">&quot;abbhdwsy&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Which gives me:</p>

<pre><code>b0d0113e0f3745b2eb8d0db1b6aad818
</code></pre>

<p>But the problem states that I need to to compute the md5&rsquo;s for that input
<em>plus a number</em>. To be clear, that&rsquo;s <em>the string representation of a number</em>
concatenated onto the end of the input, not the numerical value itself.</p>

<p>That might look like this, right?</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="nb">require</span> <span class="s1">&#39;digest&#39;</span>

<span class="nb">puts</span> <span class="no">Digest</span><span class="o">::</span><span class="no">MD5</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(</span><span class="s2">&quot;abbhdwsy0&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Yields:</p>

<pre><code>7e51386949e56ddab4f31c503de50f83
</code></pre>

<p>That&rsquo;s&hellip; really really different than the first hash!</p>

<p>Maybe I&rsquo;d like to get a few more of these?</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="nb">require</span> <span class="s1">&#39;digest&#39;</span>

<span class="nb">puts</span> <span class="no">Digest</span><span class="o">::</span><span class="no">MD5</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(</span><span class="s2">&quot;abbhdwsy1&quot;</span><span class="p">)</span>
<span class="nb">puts</span> <span class="no">Digest</span><span class="o">::</span><span class="no">MD5</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(</span><span class="s2">&quot;abbhdwsy2&quot;</span><span class="p">)</span>
<span class="nb">puts</span> <span class="no">Digest</span><span class="o">::</span><span class="no">MD5</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(</span><span class="s2">&quot;abbhdwsy3&quot;</span><span class="p">)</span>
<span class="nb">puts</span> <span class="no">Digest</span><span class="o">::</span><span class="no">MD5</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(</span><span class="s2">&quot;abbhdwsy4&quot;</span><span class="p">)</span>
<span class="nb">puts</span> <span class="no">Digest</span><span class="o">::</span><span class="no">MD5</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(</span><span class="s2">&quot;abbhdwsy5&quot;</span><span class="p">)</span>
</code></pre></div>

<pre><code>917b4f767f6713624ae0e4b4a4cd3cc9
1e2ec6125cc3e05cfd556134ae10e8ac
475a5869d93ec860881f9805460dc8fe
41ceab0f4edefdb821d47e8682adef7a
3c91defeee434cf792491e1d0e58876a
</code></pre>

<p>Look how different all those hashes are!</p>

<p>You may have noticed that my strategy here is to increment the number that I&rsquo;m
appending to my unique input. This seems like it might take a while to do
manually, oh if only there were a way to automate it! Luckily computers</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="nb">require</span> <span class="s1">&#39;digest&#39;</span>

<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="kp">loop</span> <span class="k">do</span>
    <span class="nb">puts</span> <span class="no">Digest</span><span class="o">::</span><span class="no">MD5</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(</span><span class="s2">&quot;abbhdwsy&quot;</span> <span class="o">+</span> <span class="n">i</span><span class="o">.</span><span class="n">to_s</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">end</span>
</code></pre></div>

<p>I increment that <code>i</code> value on each loop, and append it to the static input by
calling <code>to_s</code> on it (again, this gives back the <em>string</em> of the number)! Easy
peasy. This, as you would expect, fills my screen with hashes, all different,
all unique, like snowflakes, or little babies!</p>

<blockquote>
<p>Lol jk no they are not unique! They are&hellip; <em>mostly</em> different from each
other, of course, but although MD5 hashes are guaranteed to be reproducible
for any given input, they are decidedly <em>not</em> guaranteed to always be unique.
When two different inputs result in the same hash, it&rsquo;s called a <em>hash
collision</em>, and you can read a lot more about that
<a href="http://www.mscs.dal.ca/~selinger/md5collision/">here</a>.</p>
</blockquote>

<p>From there, it&rsquo;s a pretty straightforward exercise to collect the hashes I need
to compute the password. I need the first 8 hashes in this series that begin
with 5 zeros. I&rsquo;ll just throw a test case in the loop and push them into an
accumulator if they match:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="nb">require</span> <span class="s1">&#39;digest&#39;</span>

<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">acc</span> <span class="o">=</span> <span class="o">[]</span>
<span class="kp">loop</span> <span class="k">do</span>
    <span class="n">candidate</span> <span class="o">=</span> <span class="no">Digest</span><span class="o">::</span><span class="no">MD5</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(</span><span class="s2">&quot;abbhdwsy&quot;</span> <span class="o">+</span> <span class="n">i</span><span class="o">.</span><span class="n">to_s</span><span class="p">)</span>
    <span class="n">acc</span> <span class="o">&lt;&lt;</span> <span class="n">candidate</span> <span class="k">if</span> <span class="n">candidate</span><span class="o">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">4</span><span class="o">]</span> <span class="o">==</span> <span class="s2">&quot;00000&quot;</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">end</span>
</code></pre></div>

<p>That&rsquo;s almost it, really! This loop goes forever&hellip; all I need is the first 8
matches, so I can terminate the loop once I have those:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="nb">require</span> <span class="s1">&#39;digest&#39;</span>

<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">acc</span> <span class="o">=</span> <span class="o">[]</span>
<span class="k">until</span> <span class="n">acc</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">8</span>
    <span class="n">candidate</span> <span class="o">=</span> <span class="no">Digest</span><span class="o">::</span><span class="no">MD5</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(</span><span class="s2">&quot;abbhdwsy&quot;</span> <span class="o">+</span> <span class="n">i</span><span class="o">.</span><span class="n">to_s</span><span class="p">)</span>
    <span class="n">acc</span> <span class="o">&lt;&lt;</span> <span class="n">candidate</span> <span class="k">if</span> <span class="n">candidate</span><span class="o">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">4</span><span class="o">]</span> <span class="o">==</span> <span class="s2">&quot;00000&quot;</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">end</span>
<span class="nb">puts</span> <span class="n">acc</span>
</code></pre></div>

<p>running this will give me the output I need:</p>

<pre><code>000008bfb72caf77542c32b53a73439b
0000004ed0ede071d293b5f33de2dc2f
0000012be6057b2554c26bfddab18b08
00000bf3f1ca8d1f229aa50b3093b2be
00000512874cc40b764728993dd71ffb
0000069710beec5f9a1943a610be52d8
00000a8da36ee9b7e193f956cf701911
00000776b6ff41a7e30ed2d4b6663351
</code></pre>

<p>All that&rsquo;s left is to concatenate the 6th characters in these hashes into the
password. I can just do this with my eyes, of course, or I can write a little
map to do it for me!</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="nb">puts</span> <span class="n">acc</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span> <span class="p">}</span><span class="o">.</span><span class="n">join</span>
</code></pre></div>

<p>This returns <code>801b56a7</code>, which is, in fact, my password.</p>

<p><sub><a href='#toc'>toc</a></sub>
<div id="expense"></div></p>

<h1 id="this-is-expensive">This is Expensive</h1>

<p>This was the first puzzle of the year that could be considered
at all <em>computationally expensive.</em>. Indeed, it is a <em>feature</em>, not a bug, for
a cryptographic hashing function to be at least somewhat difficult to compute.
Though md5&rsquo;s are now mostly considered broken for cryptography, it&rsquo;s still what
they were designed to do. If it takes actual time to compute a hash, it&rsquo;s that
much harder to brute force guess a password if all you have is a hash.</p>

<p>But how long does this solution take, anyway?</p>

<pre><code>real	0m14.256s
user	0m14.011s
sys	0m0.096s
</code></pre>

<blockquote>
<p>This is the output of <code>time</code>. If you aren&rsquo;t familiar with that, <a href="http://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1">read
this</a>.</p>
</blockquote>

<p>That&rsquo;s not terrible, that&rsquo;s not even really <em>bad</em>, considering all
the processing we&rsquo;re doing. How much is that? How many
hashes did we process? If I just add <code>puts i</code> after the loop breaks out:</p>

<pre><code>7777890
</code></pre>

<p>So, almost 8 million. That&rsquo;s, a lot? I mean, not really, by computering
standards, but it&rsquo;s enough to kind of take a little while, I guess?</p>

<p>None of that is the point really, though, because it&rsquo;s not that I needed to
have faster or better code to solve the problem. 15 seconds is not that long to
wait. But- what if I want it to go faster! What if I had to process 800 million
hashes? Or 80 billion? Then we&rsquo;d be bumping up against some more aggressive
limits.</p>

<p>And that&rsquo;s the rabbit. &ldquo;What is a hashing algorithm, and how fast can I make it run.&rdquo;</p>

<p>And here is where I followed it.</p>

<p><sub><a href='#toc'>toc</a></sub>
<div id="hole"></div></p>

<h1 id="down-the-hole">Down the hole</h1>

<p>I wonder if I can write a faster implementation of the <a href="https://en.wikipedia.org/wiki/MD5">md5 hashing
algorithm</a> than the one that Ruby is using?
I don&rsquo;t know if I can, maybe? First I would have to be able to write <em>any</em>
implementation of the md5 hashing algorithm. How would I do that?</p>

<p>To start with, I can read the <a href="https://en.wikipedia.org/wiki/MD5">wiki page</a>, which contains
some psuedocode, that&rsquo;s helpful.</p>

<p>I can read the <a href="https://rosettacode.org/wiki/MD5">rosetta code</a> page for this
task, which contains working examples in many different languages, that is also
helpful.</p>

<p>And I also have access to the <a href="https://www.ietf.org/rfc/rfc1321.txt">original md5
specification</a> which contains both the
canonical explanation of the algorithm and a reference implementation.</p>

<p>So that&rsquo;s a good start. This is enough information to allow me to write my own
version.</p>

<p><sub><a href='#toc'>toc</a></sub>
<div id="own"></div></p>

<h1 id="my-own-md5-function">My own md5 function</h1>

<p>Let&rsquo;s say I want the md5 hash sum of my door key. It would look like this:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="k">def</span> <span class="nf">md5</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
    <span class="c1"># stuff stuff stuff</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">md5</span> <span class="s2">&quot;abbhdwsy&quot;</span>
</code></pre></div>

<p>and it should return</p>

<pre><code>b0d0113e0f3745b2eb8d0db1b6aad818
</code></pre>

<p>The first thing I need to do is turn the ruby string into an array of bytes.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="k">def</span> <span class="nf">md5</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
    <span class="n">message</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="n">bytes</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">md5</span> <span class="s2">&quot;abbhdwsy&quot;</span>
</code></pre></div>

<p>yields:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">[</span><span class="mi">97</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">104</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">119</span><span class="p">,</span> <span class="mi">115</span><span class="p">,</span> <span class="mi">121</span><span class="o">]</span>
</code></pre></div>

<p>Which are the <em>numerical values</em> of the characters in my string. These are
&ldquo;bytes&rdquo; in the sense that each value in the byte array is guaranteed to be no
more than 255, even if the input is unicode, you&rsquo;re going to get the bytes back
in byte format. This unicode lambda is a single character when it is outputted to the
screen,</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="nb">p</span> <span class="s2">&quot;λ&quot;</span><span class="o">.</span><span class="n">bytes</span>
</code></pre></div>

<p>but its machine representation is in fact two bytes long:</p>

<pre><code>[206, 187]
</code></pre>

<p><a href="https://www.youtube.com/watch?v=MijmeoH9LT4">Unicode!</a></p>

<p>Externally to the interpreter, I have no way of really knowing how ruby is
storing these values. They could be signed 64 bit ints for all I know!
And even if they are being stored as bytes- they get autopromoted just fine.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">[</span><span class="mi">97</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">104</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">119</span><span class="p">,</span> <span class="mi">115</span><span class="p">,</span> <span class="mi">121</span><span class="o">].</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span> <span class="o">**</span> <span class="mi">10</span><span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">[</span><span class="mi">73742412689492826049</span><span class="p">,</span> <span class="mi">81707280688754689024</span><span class="p">,</span> <span class="mi">81707280688754689024</span><span class="p">,</span> <span class="mi">148024428491834392576</span><span class="p">,</span> <span class="mi">100000000000000000000</span><span class="p">,</span> <span class="mi">569468379011812486801</span><span class="p">,</span> <span class="mi">404555773570791015625</span><span class="p">,</span> <span class="mi">672749994932560009201</span><span class="o">]</span>
</code></pre></div>

<p>:shrug:! Ruby has plenty of ways to work with bits and bytes, as you&rsquo;ll see,
but this is definitely not its strong point. This is usually a Good Thing- all
these messy little details are left to the interpreter and I can just focus on
expressing a problem and solution, or whatever. But when you&rsquo;re trying to
implement something to a spec and doing bit fiddly things&hellip; well&hellip;</p>

<p>The next step is to add some padding! All md5 input gets padded to add up to a
multiple of 512 bits. If it&rsquo;s <em>already</em> a multiple of 512, it gets padded one whole
new chunk.</p>

<p>The padding always starts with a 1 and then contains a bunch of 0&rsquo;s until the
last NTH bytes, which are the length of the original input value&rsquo;s length <em>in bits</em>
in little endian format. Does this sound confusing? It kind of is! But let&rsquo;s go
through it &lsquo;bit by bit&rsquo;</p>

<blockquote>
<p>lol</p>
</blockquote>

<p>First, we&rsquo;ll grab the length after we split the input string into a byte array
but before we do anything else to it.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="k">def</span> <span class="nf">md5</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
    <span class="n">message</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="n">bytes</span>
    <span class="n">orig_length</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">bytes</span><span class="o">.</span><span class="n">length</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">md5</span> <span class="s2">&quot;abbhdwsy&quot;</span>
</code></pre></div>

<blockquote>
<p>It&rsquo;s important to split it into bytes first! In the case of our earlier unicode
example and how ruby thinks about things&hellip;</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">&gt;</span> <span class="s2">&quot;λλλ&quot;</span><span class="o">.</span><span class="n">length</span> <span class="c1"># 3</span>
<span class="o">&gt;</span> <span class="s2">&quot;λλλ&quot;</span><span class="o">.</span><span class="n">bytes</span><span class="o">.</span><span class="n">length</span> <span class="c1"># 6</span>
<span class="o">&gt;</span> <span class="sb">```</span>

<span class="sb">this gives me</span>
</code></pre></div>

<p>8</p>

<pre><code>
Which makes sense, because `&quot;abbhdwsy&quot;` is 8 characters long and none of them
are more than one byte long in unicode because they all used to be ascii!

&gt; More on that:

But remember, I'm going to want the length _in bits_. Ok, I've already got 8
bytes, and there are 8 bits in a byte, so

```ruby
def md5(input)
    message = input.bytes
    orig_length_in_bits = message.length * 8
end

puts md5 &quot;abbhdwsy&quot;
</code></pre>
</blockquote>

<pre><code>64
</code></pre>

<p>I&rsquo;ll just hold onto that for later.</p>

<p><sub><a href='#toc'>toc</a></sub>
<div id="padding"></div></p>

<h1 id="padding">Padding</h1>

<p>Next, comes the padding. I&rsquo;m doing everything with byte sized operations since
I am simply building this as a little prototype for turning strings into md5
hashes&hellip; a real md5 implementation has to support streams of arbitrary numbers
of bits, but assuming the smallest unit I&rsquo;m going to deal with is a byte is ok
for learning.</p>

<p>I know I need to append a single <code>1</code> bit to the input and then start padding
with zeros. I might be tempted to do this:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
</code></pre></div>

<p>But don&rsquo;t be fooled! This is a 1, yes, but it&rsquo;s a whole byte at least on its
own! This operation would give me this:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">[</span><span class="mi">97</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">104</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">119</span><span class="p">,</span> <span class="mi">115</span><span class="p">,</span> <span class="mi">121</span><span class="p">,</span> <span class="mi">1</span><span class="o">]</span>
</code></pre></div>

<p>that might look right? But it&rsquo;s not! Consider if I look at the binary values of
all of these, padded to make them output as if they are indeed 8 bits long:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="nb">p</span> <span class="o">[</span><span class="mi">97</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">104</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">119</span><span class="p">,</span> <span class="mi">115</span><span class="p">,</span> <span class="mi">121</span><span class="p">,</span> <span class="mi">1</span><span class="o">].</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="o">.</span><span class="n">to_s</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)}</span>
</code></pre></div>

<p>gives me:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">[</span><span class="s2">&quot;01100001&quot;</span><span class="p">,</span> <span class="s2">&quot;01100010&quot;</span><span class="p">,</span> <span class="s2">&quot;01100010&quot;</span><span class="p">,</span> <span class="s2">&quot;01101000&quot;</span><span class="p">,</span> <span class="s2">&quot;01100100&quot;</span><span class="p">,</span> <span class="s2">&quot;01110111&quot;</span><span class="p">,</span> <span class="s2">&quot;01110011&quot;</span><span class="p">,</span> <span class="s2">&quot;01111001&quot;</span><span class="p">,</span> <span class="s2">&quot;00000001&quot;</span><span class="o">]</span>
</code></pre></div>

<p>As you can see, if we think of each integer in the array as a full byte, that
<code>1</code> is indeed worth 8 bits by itself! What we really wanted is a single bit set
to one followed by some number of other bits set to zero. We really want that last byte to read:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="mi">10000000</span>
</code></pre></div>

<p>So this is interesting, right? We can&rsquo;t just append a single bit to this byte
array, because ruby doesn&rsquo;t make that easy (there may be a way, but work with
me!). Plus, as I said, we&rsquo;re sort of just working with bytes here, right? So
what needs to be appended to the array if not <code>1</code>?</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="nb">p</span> <span class="s2">&quot;10000000&quot;</span><span class="o">.</span><span class="n">to_i</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div>

<p>Of course!</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="mi">128</span>
</code></pre></div>

<p>so we want to append <code>128</code> to the byte array to start the padding!</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="mi">128</span>
</code></pre></div>

<blockquote>
<p>You could also write <code>128</code> in its binary format as <code>0b10000000</code> or its
hexadecimal format as <code>0x80</code>. These are all exactly the same value.</p>
</blockquote>

<p>Now, I pad this array with <code>0</code>&rsquo;s until it&rsquo;s length in bytes is a multiple of
512 bits. (That&rsquo;s 64 bytes!)</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="k">while</span> <span class="n">message</span><span class="o">.</span><span class="n">length</span> <span class="o">%</span> <span class="mi">64</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span>
<span class="k">end</span>
</code></pre></div>

<p>That gives me,</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">[</span><span class="mi">97</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">104</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">119</span><span class="p">,</span> <span class="mi">115</span><span class="p">,</span> <span class="mi">121</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">]</span>
</code></pre></div>

<p>But ah! I missed something, right? I need to use the last 64 bits of this
padding to fill in the length that I collected from the original message!</p>

<p>So I stop that modulo 8 bytes early:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="k">while</span> <span class="n">message</span><span class="o">.</span><span class="n">length</span> <span class="o">%</span> <span class="mi">64</span> <span class="o">!=</span> <span class="mi">56</span>
    <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span>
<span class="k">end</span>
</code></pre></div>

<p>Now I need to get <code>orig_length_in_bits</code> into the right format! This part was
tricky to me, because I am not good at <code>pack</code> and <code>unpack</code> in Ruby, which
afaict is a thing that it inherited from perl and could probably do this. But
oh well, this worked too!</p>

<p>I&rsquo;ll take that original value I had grabbed earlier:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="n">orig_len_in_bits</span> <span class="c1"># 64</span>
</code></pre></div>

<p>And I&rsquo;ll turn it into a string of its hexadecimal representation!</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="n">orig_len_in_bits</span><span class="o">.</span><span class="n">to_s</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="c1"># &quot;40&quot;</span>
</code></pre></div>

<p>This will ensure that every two characters represents one byte.</p>

<p>Now, I pad this string with zeros to fill out the rest of the space I need to
fill on the remainder of the message space that I left for this! Remember, I
left 64 bits, which is 8 bytes, which is 16 characters long in hexadecimal
representation&hellip;</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span> <span class="n">orig_len_in_bits</span><span class="o">.</span><span class="n">to_s</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="c1"># &quot;0000000000000040&quot;</span>
</code></pre></div>

<blockquote>
<p>Hey ps if you find this really confusing then let&rsquo;s start a club! There is a
reason why bit twiddling is hard, and very arguably much <em>harder</em> in higher
level languages that normally take great pains to shield you from this
befuddlery.</p>
</blockquote>

<p>Right, so now I just need to split this up into its constituent hexadecimal
byte character pairs! I can do this with <code>scan</code>, which will return an array of
matches to a regular expression that are ordered by where they are in the string.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="n">orig_len_in_bits</span>
    <span class="o">.</span><span class="n">to_s</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
    <span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/../</span><span class="p">)</span>
</code></pre></div>

<p>That returns:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">[</span><span class="s2">&quot;00&quot;</span><span class="p">,</span> <span class="s2">&quot;00&quot;</span><span class="p">,</span> <span class="s2">&quot;00&quot;</span><span class="p">,</span> <span class="s2">&quot;00&quot;</span><span class="p">,</span> <span class="s2">&quot;00&quot;</span><span class="p">,</span> <span class="s2">&quot;00&quot;</span><span class="p">,</span> <span class="s2">&quot;00&quot;</span><span class="p">,</span> <span class="s2">&quot;40&quot;</span><span class="o">]</span>
</code></pre></div>

<blockquote>
<p>Almost there hang in there</p>
</blockquote>

<p>Now, we map over this array and replace each string with an actual numerical
value that is not a string. Notice that <code>hex</code> parses the string and returns its
actual integer value for that byte.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="n">orig_len_in_bits</span>
    <span class="o">.</span><span class="n">to_s</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
    <span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/../</span><span class="p">)</span>
    <span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="o">.</span><span class="n">hex</span><span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">64</span><span class="o">]</span>
</code></pre></div>

<p>Hey guess what? that&rsquo;s it. Actually wait not because it&rsquo;s gotta be <em>little
endian</em> again. Whatevs nbd.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">orig_len_in_bits</span>
    <span class="o">.</span><span class="n">to_s</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
    <span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/../</span><span class="p">)</span>
    <span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="o">.</span><span class="n">hex</span><span class="p">}</span>
    <span class="o">.</span><span class="n">reverse</span><span class="p">)</span><span class="o">.</span><span class="n">flatten!</span>
</code></pre></div>

<p>Now that I&rsquo;ve completed the padding operation, my message looks like this:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">[</span><span class="mi">97</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">104</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">119</span><span class="p">,</span> <span class="mi">115</span><span class="p">,</span> <span class="mi">121</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">]</span>
</code></pre></div>

<p>Each of these elements represents one byte, and the array itself is 64 bytes
long, which is 512 bits. Keep in mind that this is a byte array, and because of
the way we generated it, no number in the array will ever be more than 255,
which is the maximum value of a byte. But to reiterate, I have neither insight
nor control over how ruby is storing these values, so I have to be careful
about maintaining it in that state!</p>

<p>I&rsquo;ll just pull this into its own little helper function:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="k">def</span> <span class="nf">msg_to_byte_array</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="n">message</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">bytes</span>
    <span class="n">orig_len_in_bits</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">message</span><span class="o">.</span><span class="n">length</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffffffffffff</span>
    <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="mh">0x80</span>
    <span class="k">while</span> <span class="n">message</span><span class="o">.</span><span class="n">length</span> <span class="o">%</span> <span class="mi">64</span> <span class="o">!=</span> <span class="mi">56</span>
        <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span>
    <span class="k">end</span>
    <span class="n">message</span>
    <span class="p">(</span><span class="n">message</span> <span class="o">&lt;&lt;</span>
        <span class="n">orig_len_in_bits</span>
        <span class="o">.</span><span class="n">to_s</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
        <span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/../</span><span class="p">)</span>
        <span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="o">.</span><span class="n">hex</span><span class="p">}</span>
        <span class="o">.</span><span class="n">reverse</span><span class="p">)</span><span class="o">.</span><span class="n">flatten!</span>
    <span class="k">return</span> <span class="n">message</span>
<span class="k">end</span>
</code></pre></div>

<p>This is obviously the most efficient way you could ever perform this operation
in any language. This hashing function is going to be <em>ludicrous speed!</em></p>

<p>Oh yeah, one more detail to note! The spec says that in the event that the
length of the input is more than the maximum number you can encode in the 64
bits of padding left over to hold the size, that you&rsquo;ll just take the 64 least
significant bits and discard the rest. This is like, really really long.
18446744073709551615 bits long, in fact, or 2305843009213693952 bytes. Which is
2 <a href="https://en.wikipedia.org/wiki/Exbibyte">exbibytes</a>, which are actual things
I didn&rsquo;t know existed until right now.</p>

<blockquote>
<p>Wait really? That&rsquo;s <em>really</em> a lot. I don&rsquo;t think we&rsquo;re going to be using md5s
very often on exbibytes worth of data. But what do I know.</p>
</blockquote>

<p>Anyway, just bitwise <code>and</code>ing (<code>&amp;</code>) the length in bits against
18446744073709551615 will discard those higher order bits that we&rsquo;re very
likely to run into in the many applications this implementation will be used
for.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="n">orig_len_in_bits</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">message</span><span class="o">.</span><span class="n">length</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffffffffffff</span>
</code></pre></div>

<p><sub><a href='#toc'>toc</a></sub>
<div id="time"></div></p>

<h1 id="time-to-actually-process-the-hash">Time to actually process the hash</h1>

<p>We&rsquo;re here:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="k">def</span> <span class="nf">md5</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="n">message</span> <span class="o">=</span> <span class="n">msg_to_byte_array</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>

<p>&hellip;and now it&rsquo;s time to <em>actually process the hash</em>. If you haven&rsquo;t already, jump back
to the wiki for the <a href="https://en.wikipedia.org/wiki/MD5">md5 algorithm</a> and give
it a once over. It&rsquo;s not really that it&rsquo;s complicated per se- all of the most
complex operations are straightforwardly laid out for me there, but it is definitely
really fiddly, and easy to mess up.</p>

<p>First, we initialize an accumulator with some predefined constants.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="k">def</span> <span class="nf">md5</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="n">message</span> <span class="o">=</span> <span class="n">msg_to_byte_array</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="vi">@acc</span> <span class="o">=</span> <span class="o">[</span> <span class="mh">0x67452301</span><span class="p">,</span> <span class="mh">0xefcdab89</span><span class="p">,</span> <span class="mh">0x98badcfe</span><span class="p">,</span> <span class="mh">0x10325476</span> <span class="o">]</span>
<span class="k">end</span>
</code></pre></div>

<p>On first glance this looks like nothing, but if you squint you might notice
that it&rsquo;s actually these nibbles in this order:</p>

<pre><code>01234567 89abcdef fedcba98 76543210
</code></pre>

<p>expressed in <em>little endian</em>.</p>

<p>Next we&rsquo;re going to loop over the input message in chunks and adjust the
accumulator values as we go on each pass in a predetermined way. We&rsquo;re always
going to end.</p>

<p>We do the outer loop one 512 byte chunk at a time. For this input, it&rsquo;s only
one chunk, but we might as well write it to accomodate more.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="k">def</span> <span class="nf">md5</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="n">message</span> <span class="o">=</span> <span class="n">msg_to_byte_array</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="vi">@acc</span> <span class="o">=</span> <span class="o">[</span> <span class="mh">0x67452301</span><span class="p">,</span> <span class="mh">0xefcdab89</span><span class="p">,</span> <span class="mh">0x98badcfe</span><span class="p">,</span> <span class="mh">0x10325476</span> <span class="o">]</span>

    <span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="n">message</span><span class="o">.</span><span class="n">count</span><span class="o">/</span><span class="mi">64</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">message_index_base</span><span class="o">|</span>
    <span class="k">end</span>

<span class="k">end</span>
</code></pre></div>

<p>In this example, <code>message.count / 64</code> equals <code>1</code>, but ruby&rsquo;s three dotted range
is exclusive, so this loop is really saying &ldquo;do this one time, for
<code>message_index_base</code> of <code>0</code>.</p>

<p>Within this loop, we perform some specific operations 64 times. So, an inner
loop would look like:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="k">def</span> <span class="nf">md5</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="n">message</span> <span class="o">=</span> <span class="n">msg_to_byte_array</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="vi">@acc</span> <span class="o">=</span> <span class="o">[</span> <span class="mh">0x67452301</span><span class="p">,</span> <span class="mh">0xefcdab89</span><span class="p">,</span> <span class="mh">0x98badcfe</span><span class="p">,</span> <span class="mh">0x10325476</span> <span class="o">]</span>

    <span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="n">message</span><span class="o">.</span><span class="n">count</span> <span class="o">/</span> <span class="mi">64</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">message_index_base</span><span class="o">|</span>
        <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">63</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
        <span class="k">end</span>
    <span class="k">end</span>

<span class="k">end</span>
</code></pre></div>

<p>In the outer loop, we&rsquo;ll prepare a few variables to use in the inner loop.</p>

<p>First, we extract the chunk of the input message that we&rsquo;re interested in by
using the <code>message_index_base</code>:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="n">message</span><span class="o">.</span><span class="n">count</span><span class="o">/</span><span class="mi">64</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">message_index_base</span><span class="o">|</span>
    <span class="n">message_index</span> <span class="o">=</span> <span class="n">message_index_base</span> <span class="o">*</span> <span class="mi">64</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="n">message</span><span class="o">[</span><span class="n">message_index</span><span class="o">..</span><span class="n">message_index</span> <span class="o">+</span> <span class="mi">64</span><span class="o">]</span>

    <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">63</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>

<p>Again, in this case, it&rsquo;s going to be the whole message.</p>

<p>Oh, we&rsquo;ll also destructure the accumulator values into some temporary vars that
we can manipulate in the inner loop.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="vi">@acc</span>
</code></pre></div>

<p>Now, for each iteration of this inner loop, we&rsquo;ll perform a few bit fiddles and
then mutate the temporary variables. The operations are different depending on
the position we&rsquo;re at in the chunk</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="vi">@acc</span>
<span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">63</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">b</span> <span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">elsif</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">d</span> <span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">16</span>
    <span class="k">elsif</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">48</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">b</span> <span class="o">^</span> <span class="n">c</span> <span class="o">^</span> <span class="n">d</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">%</span> <span class="mi">16</span>
    <span class="k">elsif</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">c</span> <span class="o">^</span> <span class="p">(</span><span class="n">b</span> <span class="o">|</span> <span class="o">~</span><span class="n">d</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">16</span>
    <span class="k">end</span>

    <span class="n">to_rotate</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">f</span> <span class="o">+</span> <span class="vi">@constants</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">chunk</span><span class="o">[</span><span class="mi">4</span><span class="o">*</span><span class="n">g</span><span class="o">...</span><span class="mi">4</span><span class="o">*</span><span class="n">g</span><span class="o">+</span><span class="mi">4</span><span class="o">].</span><span class="n">to_int</span>
    <span class="n">new_b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">left_rotate</span><span class="p">(</span><span class="n">to_rotate</span><span class="p">,</span> <span class="vi">@rotate_amounts</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">,</span> <span class="n">new_b</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>
<span class="k">end</span>
</code></pre></div>

<p>Gross, right? :D</p>

<p>I don&rsquo;t have much to say about why these operations are what they are or the
cryptography behind them. Maybe I&rsquo;ll read up on that sometime, but for now,
this is just a play by play of an implementation of the existing spec.</p>

<p>The three lines at the end of the inner loop take the computed <code>f</code> and <code>g</code>
values and <em>doooo stuffff</em> with them. Let&rsquo;s unpack those lines!</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="n">to_rotate</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">f</span> <span class="o">+</span> <span class="vi">@constants</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">chunk</span><span class="o">[</span><span class="mi">4</span><span class="o">*</span><span class="n">g</span><span class="o">...</span><span class="mi">4</span><span class="o">*</span><span class="n">g</span><span class="o">+</span><span class="mi">4</span><span class="o">].</span><span class="n">to_int</span>
</code></pre></div>

<p>This is a preperatory step. The only thing here we haven&rsquo;t seen before is the
<code>@constants</code> array that we&rsquo;re grabbing something out of. We can compute them
like this:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="c1"># Use binary integer part of the sines of integers (Radians) as constants:</span>
<span class="vi">@constants</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span> <span class="mi">63</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">32</span> <span class="o">*</span> <span class="no">Math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">)</span><span class="o">.</span><span class="n">floor</span> <span class="p">}</span>
</code></pre></div>

<p>We take that and &lsquo;rotate&rsquo; it using a little helper function:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="n">new_b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">left_rotate</span><span class="p">(</span><span class="n">to_rotate</span><span class="p">,</span> <span class="vi">@rotate_amounts</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span>
</code></pre></div>

<p>That looks like this:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="k">def</span> <span class="nf">left_rotate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">&amp;=</span> <span class="mh">0xffffffff</span>
    <span class="p">((</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">amount</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">amount</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span>
<span class="k">end</span>
</code></pre></div>

<p>(notice the conservative <code>&amp;</code>&rsquo;s)</p>

<p>Oh, and <code>@rotate_amounts</code> is another collection of constants.</p>

<p>They look like this!</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="vi">@rotate_amounts</span> <span class="o">=</span> <span class="o">[</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span>
                    <span class="mi">5</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>
                    <span class="mi">4</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span>
                    <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">21</span> <span class="o">]</span>
</code></pre></div>

<p>Which can be generated a little less verbosely as:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="vi">@rotate_amounts</span> <span class="o">=</span> <span class="o">[[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">22</span><span class="o">]</span><span class="p">,</span>
                   <span class="o">[</span><span class="mi">5</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">20</span><span class="o">]</span><span class="p">,</span>
                   <span class="o">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="o">]</span><span class="p">,</span>
                   <span class="o">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">21</span><span class="o">]].</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="o">|[</span><span class="n">e</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">e</span><span class="o">]</span><span class="p">}</span><span class="o">.</span><span class="n">flatten</span>
</code></pre></div>

<p>(yay ruby!)</p>

<p>Lastly, reassign the the temporary vars before starting the next loop:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">,</span> <span class="n">new_b</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>
</code></pre></div>

<p>After this chunk has been processed, we just add the values back into the accumulator:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="o">].</span><span class="n">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">val</span><span class="p">,</span> <span class="n">i</span><span class="o">|</span>
    <span class="vi">@acc</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">val</span>
    <span class="vi">@acc</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;=</span> <span class="mh">0xffffffff</span>
<span class="k">end</span>
</code></pre></div>

<p>(notice we&rsquo;re again guarding against overflow with an <code>&amp;</code>)</p>

<p>Hey that&rsquo;s it! (almost).</p>

<p>The whole function looks like this now:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="k">def</span> <span class="nf">md5</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="n">message</span> <span class="o">=</span> <span class="n">msg_to_byte_array</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="vi">@acc</span> <span class="o">=</span> <span class="o">[</span> <span class="mh">0x67452301</span><span class="p">,</span> <span class="mh">0xefcdab89</span><span class="p">,</span> <span class="mh">0x98badcfe</span><span class="p">,</span> <span class="mh">0x10325476</span> <span class="o">]</span>

    <span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="n">message</span><span class="o">.</span><span class="n">count</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="ss">:/</span><span class="p">,</span> <span class="mi">64</span><span class="p">))</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">message_index_base</span><span class="o">|</span>
        <span class="n">message_index</span> <span class="o">=</span> <span class="n">message_index_base</span> <span class="o">*</span> <span class="mi">64</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">message</span><span class="o">[</span><span class="n">message_index</span><span class="o">..</span><span class="n">message_index</span> <span class="o">+</span> <span class="mi">63</span><span class="o">]</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="vi">@acc</span>

        <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">63</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span>
                <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">b</span> <span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">elsif</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span>
                <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">d</span> <span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span>
                <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">16</span>
            <span class="k">elsif</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">48</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">b</span> <span class="o">^</span> <span class="n">c</span> <span class="o">^</span> <span class="n">d</span>
                <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">%</span> <span class="mi">16</span>
            <span class="k">elsif</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">c</span> <span class="o">^</span> <span class="p">(</span><span class="n">b</span> <span class="o">|</span> <span class="o">~</span><span class="n">d</span><span class="p">)</span>
                <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">16</span>
            <span class="k">end</span>

            <span class="n">to_rotate</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">f</span> <span class="o">+</span> <span class="vi">@constants</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">chunk</span><span class="o">[</span><span class="mi">4</span><span class="o">*</span><span class="n">g</span><span class="o">...</span><span class="mi">4</span><span class="o">*</span><span class="n">g</span><span class="o">+</span><span class="mi">4</span><span class="o">].</span><span class="n">to_int</span>
            <span class="n">new_b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">left_rotate</span><span class="p">(</span><span class="n">to_rotate</span><span class="p">,</span> <span class="vi">@rotate_amounts</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">,</span> <span class="n">new_b</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>
        <span class="k">end</span>

        <span class="o">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="o">].</span><span class="n">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">val</span><span class="p">,</span> <span class="n">i</span><span class="o">|</span>
            <span class="vi">@acc</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">val</span>
            <span class="vi">@acc</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;=</span> <span class="mh">0xffffffff</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="vi">@acc</span>
<span class="k">end</span>
</code></pre></div>

<blockquote>
<p>If you&rsquo;re wondering about that stupid <code>.send(:/, 64)</code> thing, blame my syntax highlighter.</p>
</blockquote>

<p>Now,</p>

<pre><code>md5(&quot;abbhdwsy&quot;)
</code></pre>

<p>Yields:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">[</span><span class="mi">1041354928</span><span class="p">,</span> <span class="mi">2990880527</span><span class="p">,</span> <span class="mi">2970455531</span><span class="p">,</span> <span class="mi">416852662</span><span class="o">]</span>
</code></pre></div>

<p>Ah, oh yeah, we gotta transform those values into a hexadecimal output string!
This is a little tricky but not too bad. First, we need to shift each of these
values over so that when we &ldquo;or&rdquo; (<code>|</code>) all 4 32 bits together, we get a single 128 bit
number.</p>

<p>First we&rsquo;ll turn the accumulator into an enumerator:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="vi">@acc</span><span class="o">.</span><span class="n">each_with_index</span>
</code></pre></div>

<p>then map over the tuple pairs of element and index to shift the bits:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="vi">@acc</span><span class="o">.</span><span class="n">each_with_index</span>
    <span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="p">,</span><span class="n">i</span><span class="o">|</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">*</span> <span class="n">i</span><span class="p">)}</span>
</code></pre></div>

<p>then reduce the resulting elements by or-ring them all together:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="vi">@acc</span><span class="o">.</span><span class="n">each_with_index</span>
    <span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="p">,</span><span class="n">i</span><span class="o">|</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">*</span> <span class="n">i</span><span class="p">)}</span>
    <span class="o">.</span><span class="n">reduce</span><span class="p">{</span><span class="o">|</span><span class="n">acc</span><span class="p">,</span> <span class="n">e</span><span class="o">|</span> <span class="n">acc</span> <span class="o">|</span> <span class="n">e</span><span class="p">}</span>
</code></pre></div>

<p>Ok still going&hellip; turn the resulting number into a hexadecimal string:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="vi">@acc</span><span class="o">.</span><span class="n">each_with_index</span>
    <span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="p">,</span><span class="n">i</span><span class="o">|</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">*</span> <span class="n">i</span><span class="p">)}</span>
    <span class="o">.</span><span class="n">reduce</span><span class="p">{</span><span class="o">|</span><span class="n">acc</span><span class="p">,</span> <span class="n">e</span><span class="o">|</span> <span class="n">acc</span> <span class="o">|</span> <span class="n">e</span><span class="p">}</span>
    <span class="o">.</span><span class="n">to_s</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
</code></pre></div>

<p>then pad the string to make sure we have the right number of digits:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="vi">@acc</span><span class="o">.</span><span class="n">each_with_index</span>
    <span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="p">,</span><span class="n">i</span><span class="o">|</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">*</span> <span class="n">i</span><span class="p">)}</span>
    <span class="o">.</span><span class="n">reduce</span><span class="p">{</span><span class="o">|</span><span class="n">acc</span><span class="p">,</span> <span class="n">e</span><span class="o">|</span> <span class="n">acc</span> <span class="o">|</span> <span class="n">e</span><span class="p">}</span>
    <span class="o">.</span><span class="n">to_s</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
    <span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
</code></pre></div>

<p><em>then</em> split <em>that</em> string up into pairs of characters to isolate the bytes</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="vi">@acc</span><span class="o">.</span><span class="n">each_with_index</span>
    <span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="p">,</span><span class="n">i</span><span class="o">|</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">*</span> <span class="n">i</span><span class="p">)}</span>
    <span class="o">.</span><span class="n">reduce</span><span class="p">{</span><span class="o">|</span><span class="n">acc</span><span class="p">,</span> <span class="n">e</span><span class="o">|</span> <span class="n">acc</span> <span class="o">|</span> <span class="n">e</span><span class="p">}</span>
    <span class="o">.</span><span class="n">to_s</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
    <span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/../</span><span class="p">)</span>
</code></pre></div>

<p><em>then</em> reverse the whole thing and join it together to get you&hellip;</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="vi">@acc</span><span class="o">.</span><span class="n">each_with_index</span>
    <span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="p">,</span><span class="n">i</span><span class="o">|</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">*</span> <span class="n">i</span><span class="p">)}</span>
    <span class="o">.</span><span class="n">reduce</span><span class="p">{</span><span class="o">|</span><span class="n">acc</span><span class="p">,</span> <span class="n">e</span><span class="o">|</span> <span class="n">acc</span> <span class="o">|</span> <span class="n">e</span><span class="p">}</span>
    <span class="o">.</span><span class="n">to_s</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
    <span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="sr">/../</span><span class="p">)</span>
    <span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">join</span>
</code></pre></div>

<p><em>gasp</em> <em>the final output</em>.</p>

<p><sub><a href='#toc'>toc</a></sub>
<div id="output"></div></p>

<h1 id="output">Output</h1>

<p>Did it work?</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="nb">require</span> <span class="s2">&quot;digest&quot;</span>
<span class="vi">@door</span> <span class="o">=</span> <span class="s2">&quot;abbhdwsy&quot;</span>
<span class="nb">puts</span> <span class="n">md5</span><span class="p">(</span><span class="vi">@door</span><span class="p">)</span>
<span class="nb">puts</span> <span class="no">Digest</span><span class="o">::</span><span class="no">MD5</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(</span><span class="vi">@door</span><span class="p">)</span>
</code></pre></div>

<pre><code>b0d0113e0f3745b2eb8d0db1b6aad818
b0d0113e0f3745b2eb8d0db1b6aad818
</code></pre>

<p>Sweet.</p>

<p><sub><a href='#toc'>toc</a></sub>
<div id="quite"></div></p>

<h1 id="i-am-quite-sure-my-homegrown-hashing-function-will-outperform-ruby-s-built-in-version">I am quite sure my homegrown hashing function will outperform Ruby&rsquo;s built in version</h1>

<p>Now that I have my custom built md5 hashing function, I bet I can use it to
compute the answer to this question a lot faster.</p>

<p>I swapped the function out and tried it out with the same solution code from above.</p>

<pre><code>real	38m18.696s
</code></pre>

<p>Wow ok, that&rsquo;s hella slow, but why? I thought I was using Ruby&rsquo;s built in
function, so shouldn&rsquo;t my own version written in Ruby be comparable on the same task?</p>

<p>The answer to this is pretty simple. Ruby&rsquo;s built in function isn&rsquo;t written in
Ruby at all, it&rsquo;s a compiled C extension! The business end of the
<code>Digest::MD5.hexdigest()</code> is <em>all</em> C, and it turns out it&rsquo;s already <em>really
fast</em>. <a href="https://github.com/ruby/ruby/blob/trunk/ext/digest/md5/md5.c">It lives here in the
source</a>, and was
first commited by Matz himself in 1998 as a migration commit from Subversion.</p>

<pre><code>commit 3db12e8b236ac8f88db8eb4690d10e4a3b8dbcd4
Author: matz &lt;matz@b2dd03c8-39d4-4d8f-98ff-823fe69b080e&gt;
Date:   Fri Jan 16 12:13:05 1998 +0000

    Initial revision


    git-svn-id: svn+ssh://ci.ruby-lang.org/ruby/trunk@2 b2dd03c8-39d4-4d8f-98ff-823fe69b080e
</code></pre>

<p><sub><a href='#toc'>toc</a></sub>
<div id="c"></div></p>

<h1 id="let-s-c">Let&rsquo;s C.</h1>

<p>So it&rsquo;s pretty obvious that writing my own md5 function in pure Ruby is never
going to cut it. Regardless of how many (of the probably many) inefficiencies
in the above code I find, stamp out, or reduce, I&rsquo;m never going to come close
to the pure C extension that ruby already has built in.</p>

<p>Here&rsquo;s an aside about speed. Like many beginners, when I was first learning to
code I absorbed a lot of information and chatter about programming in general
and specific programming languages and how they related to each other. But at
the time, I had no perspective on anything. People often said things like &ldquo;Ruby
is slow&rdquo;. And I thought that meant &ldquo;Ruby is like, actually really slow and
useless.&rdquo; It turns out, well yeah no shit Ruby is slow for really
computationally intensive tasks like computing an MD5, it&rsquo;s just <em>not designed</em>
to excel for that type of application. It&rsquo;s designed to be flexible, and
expressive, and a joy to work in, and it&rsquo;s plenty fast enough for almost
anything you might want to use it for in a general context like that&hellip; but if
you have a task like this that <em>really is</em> this computationally expensive, well
<em>of course</em> it&rsquo;s too slow, and blaming ruby for that just straight up <em>isn&rsquo;t
fair,</em> and totally misses the point.</p>

<p>This goes for Python too! Or other dynamic languages! Python might be faster
than Ruby for some things, and vice versa, but they are essentially in the same
class, and designed with similar goals in mind. We can nitpick the differences
of course, but when you&rsquo;re talking about apples to oranges, yeah they&rsquo;re
different but they&rsquo;re a lot more similar to each other than say, apples to
rocketships, you know what I mean?</p>

<p>The most logical thing to do when you find an application that a dynamic
language is ill suited to because of speed constraints is simply to not use
that language. So with that in mind, let&rsquo;s port that solution to C!</p>

<p>It&rsquo;s going to basically have the same shape, let&rsquo;s start with this:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">char</span> <span class="o">*</span><span class="nf">md5digest</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// stuff stuff stuff</span>
<span class="p">}</span>
</code></pre></div>

<p>Just like in the ruby version, we&rsquo;re passing in a &ldquo;string&rdquo;. C strings are
<em>already</em> basically represented as contiguous bytes in memory, so we don&rsquo;t need
to convert them or anything like that!</p>

<p>We do have to pad the input though, here&rsquo;s what I ended up with:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">char</span> <span class="o">*</span><span class="nf">md5digest</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Message</span><span class="o">*</span> <span class="n">padded_msg</span> <span class="o">=</span> <span class="n">md5padding</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>A wild helper function appears!</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">static</span> <span class="k">struct</span> <span class="n">Message</span><span class="o">*</span> <span class="nf">md5padding</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">orig_length_in_bytes</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">orig_length_in_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">orig_length_in_bytes</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffffffffffff</span><span class="p">;</span>

    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">padded_length</span> <span class="o">=</span> <span class="n">orig_length_in_bytes</span><span class="p">;</span>

    <span class="n">padded_length</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">padded_length</span> <span class="o">%</span> <span class="mi">64</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">padded_length</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">output_buffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">padded_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">orig_length_in_bytes</span><span class="p">);</span>

    <span class="n">output_buffer</span><span class="p">[</span><span class="n">orig_length_in_bytes</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">orig_length_in_bytes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">64</span> <span class="o">!=</span> <span class="mi">56</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">output_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
    <span class="p">}</span>

<span class="c1">// TODO: proper bit shifting here instead of this garbage &lt;&lt;&lt;</span>
    <span class="n">output_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">orig_length_in_bits</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span><span class="p">;</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">64</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">output_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="c1">// TODO: proper bit shifting here instead of this garbage ^^^</span>

    <span class="k">struct</span> <span class="n">Message</span><span class="o">*</span> <span class="n">output_msg</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Message</span><span class="p">));</span>
    <span class="n">output_msg</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">output_buffer</span><span class="p">;</span>
    <span class="n">output_msg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">padded_length</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">output_msg</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>This function is basically doing the same thing as the ruby version! I grab the
original length of the input in bytes and bits&hellip;</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">orig_length_in_bytes</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">orig_length_in_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">orig_length_in_bytes</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffffffffffff</span><span class="p">;</span>
</code></pre></div>

<p>Then I compute what the final padded length of the message will be by adding 4
(4 bytes for the initial <code>1</code> bit followed by zeros&hellip;) and then counting how
many bytes it will take to have a multiple of 64 bytes.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="n">padded_length</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">padded_length</span> <span class="o">%</span> <span class="mi">64</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">padded_length</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>

<p>Next I <code>malloc</code> an output buffer with this computed size and copy the original input into it:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">output_buffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">padded_length</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">orig_length_in_bytes</span><span class="p">);</span>
</code></pre></div>

<p>Finally, we&rsquo;ll actually pad the output, with the initial <code>128</code> byte
(<code>1000000</code>), a bunch of zeros, followed by the original size in bits and a few
more zeros.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="n">output_buffer</span><span class="p">[</span><span class="n">orig_length_in_bytes</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">orig_length_in_bytes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">64</span> <span class="o">!=</span> <span class="mi">56</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">output_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
    <span class="p">}</span>

<span class="c1">// TODO: proper bit shifting here instead of this garbage &lt;&lt;&lt;</span>
    <span class="n">output_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">orig_length_in_bits</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span><span class="p">;</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">64</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">output_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="c1">// TODO: proper bit shifting here instead of this garbage ^^^</span>
</code></pre></div>

<p>That TODO is there because as it stands, I&rsquo;m only saving one byte worth of
length- the input could only be up to 256 bits (32 bytes) long. This is just
laziness on my part since my input will never be longer than that for this
problem space, but it <em>should</em> be a little endian 64 bit (unsigned long) value
(that conversion from an <code>unsigned long</code> to a little endian long is the &lsquo;proper
bit shifting&rsquo; I&rsquo;m referring to).</p>

<blockquote>
<p>A reminder that also neither of these implementations support arbitrarily
long bit streams as input, which is part of the official spec. So like, don&rsquo;t
use these for anything I guess? Whatevah.</p>
</blockquote>

<p>You might have noticed the return value of this padding function is something
called a <code>Message</code> which is not yet a real thing! I&rsquo;ll make a simple little
struct that will hold a pointer to the beginning of the padded message I just
constructed, and the size of the whole thing. I can&rsquo;t use <code>strlen()</code> on the padded message because it contains all those padded zeros, which would be incorrectly interpreted as terminating null bytes).</p>

<blockquote>
<p>Also like, this is one of those things about C that I feel like really screws
beginners up. For a while it was easiest for me to think about <code>char*</code> typed
variables as &ldquo;strings&rdquo; which, they are of course, but <em>really</em> they&rsquo;re a pointer
to the beginning of a contiguous memory array of indeterminate length, of which
a null terminated string is a special case. <a href="http://queue.acm.org/detail.cfm?id=2010365">Here&rsquo;s a neat post about the
history of null terminated
strings.</a></p>
</blockquote>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">struct</span> <span class="n">Message</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">start</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>So anyway, I malloc space for that <code>Message</code> and fill the space with both the
pointer to the beginning of the <code>output_buffer</code> and also the <code>padded_length</code> I
computed earlier.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="k">struct</span> <span class="n">Message</span><span class="o">*</span> <span class="n">output_msg</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Message</span><span class="p">));</span>
    <span class="n">output_msg</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">output_buffer</span><span class="p">;</span>
    <span class="n">output_msg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">padded_length</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">output_msg</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>And I&rsquo;ve got my thing I need to operate on!</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">char</span> <span class="o">*</span><span class="nf">md5digest</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Message</span><span class="o">*</span> <span class="n">padded_msg</span> <span class="o">=</span> <span class="n">md5padding</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>From there, the code is essentially identical to the ruby version, with obvious differences for C syntax and types, etc:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">char</span> <span class="o">*</span><span class="nf">md5digest</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Message</span><span class="o">*</span> <span class="n">padded_msg</span> <span class="o">=</span> <span class="n">md5padding</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">acc</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x67452301</span><span class="p">,</span> <span class="mh">0xefcdab89</span><span class="p">,</span> <span class="mh">0x98badcfe</span><span class="p">,</span> <span class="mh">0x10325476</span> <span class="p">};</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">chunk_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chunk_index</span> <span class="o">&lt;</span> <span class="n">padded_msg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">/</span> <span class="mi">64</span><span class="p">;</span> <span class="n">chunk_index</span> <span class="o">+=</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">b</span> <span class="o">=</span> <span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">c</span> <span class="o">=</span> <span class="n">acc</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">d</span> <span class="o">=</span> <span class="n">acc</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">g</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">b</span> <span class="o">&amp;</span> <span class="n">d</span><span class="p">);</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">d</span> <span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>
                <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">16</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">48</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">b</span> <span class="o">^</span> <span class="n">c</span> <span class="o">^</span> <span class="n">d</span><span class="p">;</span>
                <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">%</span> <span class="mi">16</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">c</span> <span class="o">^</span> <span class="p">(</span><span class="n">b</span> <span class="o">|</span> <span class="o">~</span><span class="n">d</span><span class="p">);</span>
                <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">16</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">to_rotate</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">f</span> <span class="o">+</span> <span class="n">constants</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span>
               <span class="p">(</span><span class="n">padded_msg</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">[</span><span class="n">g</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]</span>       <span class="o">|</span>
                <span class="n">padded_msg</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">[</span><span class="n">g</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span>  <span class="o">|</span>
                <span class="n">padded_msg</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">[</span><span class="n">g</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span>
                <span class="n">padded_msg</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">[</span><span class="n">g</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>

            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">left_rotate</span><span class="p">(</span><span class="n">to_rotate</span><span class="p">,</span> <span class="n">rotate_amounts</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">new_b</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
        <span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
        <span class="n">acc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">acc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
        <span class="n">acc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span>
        <span class="n">acc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="mh">0xffffffff</span><span class="p">;</span>


    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">padded_msg</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">padded_msg</span><span class="p">);</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">outstr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">128</span><span class="p">);</span>

    <span class="n">sprintf</span><span class="p">(</span><span class="n">outstr</span><span class="p">,</span> <span class="s">&quot;%08lx%08lx%08lx%08lx&quot;</span><span class="p">,</span>
            <span class="n">bitswap</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">bitswap</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">bitswap</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="n">bitswap</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
          <span class="p">);</span>

    <span class="k">return</span> <span class="n">outstr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>A couple of things to point out! There&rsquo;s actually a lot <em>less</em> fuckery going on
with this version, since C is ideal for operating on arrays of bytes in a way
ruby is most definitely <em>not</em>. Gone is that convoluted string cast to
facilitate turning a hex representation into a little endian version- instead I
simply use a little macro I defined called <code>bitswap</code> to shuffle those bytes
around directly:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cp">#define bitswap(NUM) ((NUM&gt;&gt;24)&amp;0xff) | ((NUM&lt;&lt;8)&amp;0xff0000) | ((NUM&gt;&gt;8)&amp;0xff00) | ((NUM&lt;&lt;24)&amp;0xff000000)</span>
</code></pre></div>

<p>Oh and also I have that old friend <code>left_rotate()</code> defined as well:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">left_rotate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">amount</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">amount</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Oh and instead of being clever with computing both <code>constants</code> and
<code>rotate_amounts</code>, I think it&rsquo;s much preferable to define them explicitly as
constant arrays. This will simply be loaded into memory and accessed directly,
and defining them as constant arrays I suspect will make compile time
optimizations easier.</p>

<blockquote>
<p>This is just a guess though, I honestly haven&rsquo;t dipped lower than C yet.
Wouldn&rsquo;t mind learning more about compilers and assembly (probably x86) this
coming year, but we&rsquo;ll see.</p>
</blockquote>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">constants</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span> <span class="mh">0xd76aa478</span><span class="p">,</span> <span class="mh">0xe8c7b756</span><span class="p">,</span> <span class="mh">0x242070db</span><span class="p">,</span> <span class="mh">0xc1bdceee</span><span class="p">,</span>
 <span class="mh">0xf57c0faf</span><span class="p">,</span> <span class="mh">0x4787c62a</span><span class="p">,</span> <span class="mh">0xa8304613</span><span class="p">,</span> <span class="mh">0xfd469501</span><span class="p">,</span>
 <span class="mh">0x698098d8</span><span class="p">,</span> <span class="mh">0x8b44f7af</span><span class="p">,</span> <span class="mh">0xffff5bb1</span><span class="p">,</span> <span class="mh">0x895cd7be</span><span class="p">,</span>
 <span class="mh">0x6b901122</span><span class="p">,</span> <span class="mh">0xfd987193</span><span class="p">,</span> <span class="mh">0xa679438e</span><span class="p">,</span> <span class="mh">0x49b40821</span><span class="p">,</span>
 <span class="mh">0xf61e2562</span><span class="p">,</span> <span class="mh">0xc040b340</span><span class="p">,</span> <span class="mh">0x265e5a51</span><span class="p">,</span> <span class="mh">0xe9b6c7aa</span><span class="p">,</span>
 <span class="mh">0xd62f105d</span><span class="p">,</span> <span class="mh">0x02441453</span><span class="p">,</span> <span class="mh">0xd8a1e681</span><span class="p">,</span> <span class="mh">0xe7d3fbc8</span><span class="p">,</span>
 <span class="mh">0x21e1cde6</span><span class="p">,</span> <span class="mh">0xc33707d6</span><span class="p">,</span> <span class="mh">0xf4d50d87</span><span class="p">,</span> <span class="mh">0x455a14ed</span><span class="p">,</span>
 <span class="mh">0xa9e3e905</span><span class="p">,</span> <span class="mh">0xfcefa3f8</span><span class="p">,</span> <span class="mh">0x676f02d9</span><span class="p">,</span> <span class="mh">0x8d2a4c8a</span><span class="p">,</span>
 <span class="mh">0xfffa3942</span><span class="p">,</span> <span class="mh">0x8771f681</span><span class="p">,</span> <span class="mh">0x6d9d6122</span><span class="p">,</span> <span class="mh">0xfde5380c</span><span class="p">,</span>
 <span class="mh">0xa4beea44</span><span class="p">,</span> <span class="mh">0x4bdecfa9</span><span class="p">,</span> <span class="mh">0xf6bb4b60</span><span class="p">,</span> <span class="mh">0xbebfbc70</span><span class="p">,</span>
 <span class="mh">0x289b7ec6</span><span class="p">,</span> <span class="mh">0xeaa127fa</span><span class="p">,</span> <span class="mh">0xd4ef3085</span><span class="p">,</span> <span class="mh">0x04881d05</span><span class="p">,</span>
 <span class="mh">0xd9d4d039</span><span class="p">,</span> <span class="mh">0xe6db99e5</span><span class="p">,</span> <span class="mh">0x1fa27cf8</span><span class="p">,</span> <span class="mh">0xc4ac5665</span><span class="p">,</span>
 <span class="mh">0xf4292244</span><span class="p">,</span> <span class="mh">0x432aff97</span><span class="p">,</span> <span class="mh">0xab9423a7</span><span class="p">,</span> <span class="mh">0xfc93a039</span><span class="p">,</span>
 <span class="mh">0x655b59c3</span><span class="p">,</span> <span class="mh">0x8f0ccc92</span><span class="p">,</span> <span class="mh">0xffeff47d</span><span class="p">,</span> <span class="mh">0x85845dd1</span><span class="p">,</span>
 <span class="mh">0x6fa87e4f</span><span class="p">,</span> <span class="mh">0xfe2ce6e0</span><span class="p">,</span> <span class="mh">0xa3014314</span><span class="p">,</span> <span class="mh">0x4e0811a1</span><span class="p">,</span>
 <span class="mh">0xf7537e82</span><span class="p">,</span> <span class="mh">0xbd3af235</span><span class="p">,</span> <span class="mh">0x2ad7d2bb</span><span class="p">,</span> <span class="mh">0xeb86d391</span> <span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rotate_amounts</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span>
  <span class="mi">5</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>
  <span class="mi">4</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span>
  <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">21</span> <span class="p">};</span>
</code></pre></div>

<p>Now! I can port my original solution to the problem to C and see waht kinds of
/l33t p3rf gAiNs/ I&rsquo;ve earned myself.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;md5.h&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">door</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">test</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">7777890</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sprintf</span><span class="p">(</span><span class="n">door</span><span class="p">,</span> <span class="s">&quot;abbhdwsy%i&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">cand</span> <span class="o">=</span> <span class="n">md5digest</span><span class="p">(</span><span class="n">door</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
            <span class="n">test</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">cand</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="s">&quot;00000&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="n">cand</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>prints out:</p>

<pre><code>801b56a7
</code></pre>

<p>Seems familiar! This looks fine. How long does it take?</p>

<pre><code>real    0m17.296s
</code></pre>

<p>That&rsquo;s a LOT better than the pure ruby version, of course! And it&rsquo;s in the same
ballpark as the original ruby solution I started with that uses the built in
hash function, which makes sense, since they are both in C. I am not at all
surprised that the library function is slightly faster than my half assed
version, even despite the ruby interpreter&rsquo;s overhead, whatever that is.</p>

<p>I could probably work harder on my C version and shave off some of those extra
seconds, I could probably even beat the built in Ruby version if I found enough
tricks and traps to optimize it&hellip; but I&rsquo;ve got a better idea.</p>

<p><sub><a href='#toc'>toc</a></sub>
<div id="opencl"></div></p>

<h1 id="act-iii-opencl">Act III: OpenCL</h1>

<p>Strap in things are about to get <em>really fast</em></p>

<p>Ok so a disclaimer before I really get into this part:</p>

<p><img src="http://i0.kym-cdn.com/photos/images/newsfeed/000/234/142/196.jpg" alt="img" /></p>

<p>I mean, that&rsquo;s not <em>entirely</em> true of course, I am happy to report that after a
lot of research and trial and error I was able to make this thing work the way
I hoped I would be able to.</p>

<p>But I will refrain from explaining everything in minute detail in this section
because I don&rsquo;t have enough experience with OpenCL to feel completely
comfortable doing that. And to be honest, I&rsquo;m really tired and I really want to
post this, and this post is already super long, and I might just write more
detailed info about OpenCL after I learn more about it. I&rsquo;ll cover the broad
strokes about what I learned though!</p>

<p>So, OpenCL is a framework for writing general purpose code that can be run on
your GPU. The GPU (graphics processing unit) is <em>completely separate</em>
physically from the CPU (central processing unit) in your computer.</p>

<blockquote>
<p>(if you have one that is! also there are now integrated graphics chipsets that
do the work of the gpu on the cpu, and some other stuff I don&rsquo;t know about
    much!).</p>
</blockquote>

<p>The GPU is highly optimized for doing many many small tasks in parallel. As its
name suggests, it it mostly used for graphics processing, which is a perfect
use case for highly paralellized computations.</p>

<p>It&rsquo;s often compared to its closed source sibling CUDA, which is nvidia&rsquo;s
proprietary framework that does basically the same thing. Linux MDFL Linus
Torvalds is a <a href="https://www.youtube.com/watch?v=55XVnJ_0qhg">big fan</a>.</p>

<hr>

<p>I started by using
<a href="https://www.fixstars.com/en/opencl/book/OpenCLProgrammingBook/first-opencl-program/">this</a>
as a template. It&rsquo;s a LOT of boilerplate to get the environment set up! I am
going to refrain from explaining that in detail for a couple of reasons. I
don&rsquo;t <em>really</em> understand it well enough yet to provide a helpful perspective,
it&rsquo;s a little bit not necessary to understand the broad strokes, and also that book
does an <em>excellent</em> job of going through <a href="https://www.fixstars.com/en/opencl/book/OpenCLProgrammingBook/basic-program-flow/">line by
line</a>.</p>

<p>I have to write <em>two different</em> programs here- one to run on the
<em>host</em> side and another that runs on the <em>device</em> side. The device side code is
basically c99, but is subject to a set of restrictions that follow from the
limitations of the hardware and how the program actually runs on it.</p>

<p>Let&rsquo;s look at the kernel function from the hello world example above:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">__kernel</span> <span class="kt">void</span> <span class="nf">hello</span><span class="p">(</span><span class="n">__global</span> <span class="kt">char</span><span class="o">*</span> <span class="n">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;H&#39;</span><span class="p">;</span>
    <span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;e&#39;</span><span class="p">;</span>
    <span class="n">string</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;l&#39;</span><span class="p">;</span>
    <span class="n">string</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;l&#39;</span><span class="p">;</span>
    <span class="n">string</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;o&#39;</span><span class="p">;</span>
    <span class="n">string</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;,&#39;</span><span class="p">;</span>
    <span class="n">string</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
    <span class="n">string</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;W&#39;</span><span class="p">;</span>
    <span class="n">string</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;o&#39;</span><span class="p">;</span>
    <span class="n">string</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;r&#39;</span><span class="p">;</span>
    <span class="n">string</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;l&#39;</span><span class="p">;</span>
    <span class="n">string</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;d&#39;</span><span class="p">;</span>
    <span class="n">string</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;!&#39;</span><span class="p">;</span>
    <span class="n">string</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Notice a few things! This function returns nothing (<code>void</code>). It actually
doesn&rsquo;t make any sense for a kernel function to return anything at all- where
would that return value go? Instead, we pass in a pointer to a shared memory
object (in this case <code>string</code>) which can be manipulated from within the device
code and accessed after that task has been run from the host&rsquo;s code.</p>

<p>Let&rsquo;s follow that backwards! Where does that pointer get &lsquo;passed in&rsquo;?</p>

<p>The relevant line in the host code are here on line 66:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cm">/* Set OpenCL Kernel Parameters */</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">clSetKernelArg</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cl_mem</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">memobj</span><span class="p">);</span>
</code></pre></div>

<p>A few things! The return value of this function is an integer that is 0 on
success and an <a href="https://streamcomputing.eu/blog/2013-04-28/opencl-error-codes/">error
code</a> on error.
It&rsquo;s being assigned to <code>ret</code> to capture that in case it isn&rsquo;t successful. What
are these arguments? <a href="https://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clSetKernelArg.html">The docs can tell
us!</a></p>

<ul>
<li><p><code>kernel</code> is the compiled kernel object that is being manipulated.</p></li>

<li><p><code>0</code> is the index of the argument I&rsquo;m passing in as it related to the arg list
of the kernel function (whose signature is just <code>__global char *string</code>, so
there is only that one argument)</p></li>

<li><p><code>sizeof(cl_mem)</code> is the size of what is being passed in</p>

<ul>
<li><code>cl_mem</code> is the return value of
<a href="https://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clCreateBuffer.html"><code>clCreateBuffer</code></a>, which I&rsquo;ll come back to in a sec</li>
</ul></li>

<li><p>and finally <code>(void *)&amp;memobj</code> is a pointer to the memory on the host that I
want to be copied into from the host buffer into the device buffer. It&rsquo;s
being cast to a void pointer because that&rsquo;s the signature of <code>clSetKernelArg</code>
I guess? Seems legit.</p></li>
</ul>

<p>So where is <code>memobj</code> coming from? Line 54!</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cm">/* Create Memory Buffer */</span>
<span class="n">memobj</span> <span class="o">=</span> <span class="n">clCreateBuffer</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">CL_MEM_READ_WRITE</span><span class="p">,</span> <span class="n">MEM_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">);</span>
</code></pre></div>

<p>I won&rsquo;t enumerate these args, but basically this function creates a memory
buffer suitable for copying into the device code. <a href="https://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clCreateBuffer.html">More in the
docs!</a></p>

<p>When the kernel is actually
<a href="https://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clEnqueueTask.html"><em>executed</em></a>
in line 70:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cm">/* Execute OpenCL Kernel */</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">clEnqueueTask</span><span class="p">(</span><span class="n">command_queue</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
</code></pre></div>

<p>the kernel code from above is run and the memory object that was &ldquo;passed in&rdquo; is
manipulated on the device side.</p>

<p>Getting that memory back out of the device is <a href="https://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clEnqueueReadBuffer.html">just as
convoluted</a>.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cm">/* Copy results from the memory buffer */</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">clEnqueueReadBuffer</span><span class="p">(</span><span class="n">command_queue</span><span class="p">,</span> <span class="n">memobj</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
<span class="n">MEM_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">),</span><span class="n">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div>

<blockquote>
<p>(Just as there is a <code>clEnqueueReadBuffer</code>, there is also a
<a href="https://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clEnqueueWriteBuffer.html"><code>clEnqueueWriteBuffer</code></a>
to move data from host to device side)</p>
</blockquote>

<p>The memory object was read into <code>string</code> which is now just in the host side
memory space, and lo it is done:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span> <span class="cm">/* Display Result */</span>
 <span class="n">puts</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
</code></pre></div>

<pre><code>Hello World!
</code></pre>

<p>Phew.</p>

<hr>

<p>So let&rsquo;s think for a second about the original problem space. I want to compute
a bunch of md5 hashes and then save a few that fulfill a criteria (in this case
having those five leading <code>0</code>s)</p>

<p>The only relation these input strings have to each other is that I want to find
a way to compute each one only once. None of the actual computations inside of
an individual kernel depend at all on any of the others. This is a perfect task
to parallelize! Everything is awesome!</p>

<p>Not only that, but the code I want to write for the md5 function needs to be in
C! I&rsquo;ve basically already written it! All I need to do is make a kernel
function that computes an md5, find a way to distribute the work effectively
over the gpu cores, and I should have that leet perf gain I wanted since the
very beginning of this nerd snipe! Let&rsquo;s get crackin.</p>

<p><sub><a href='#toc'>toc</a></sub>
<div id="crackin"></div></p>

<h1 id="crackin">Crackin&rsquo;</h1>

<p>So yeah, I&rsquo;ve basically already written this, but to get it running on the GPU
I&rsquo;ll have to make some small changes!</p>

<p>First, I need both <code>bitswap</code> and <code>left_rotate</code> completely as is:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cp">#define bitswap(NUM) ((NUM&gt;&gt;24)&amp;0xff) | ((NUM&lt;&lt;8)&amp;0xff0000) | ((NUM&gt;&gt;8)&amp;0xff00) | ((NUM&lt;&lt;24)&amp;0xff000000)</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">left_rotate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">amount</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">amount</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Next, I&rsquo;ll show the signature of the function!</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">__kernel</span> <span class="kt">void</span> <span class="nf">md5thing</span><span class="p">(</span>
        <span class="n">__global</span> <span class="kt">long</span><span class="o">*</span> <span class="n">constants</span><span class="p">,</span>
        <span class="n">__global</span> <span class="kt">long</span><span class="o">*</span> <span class="n">rotate_amounts</span>
<span class="p">)</span> <span class="p">{</span>
</code></pre></div>

<p>I&rsquo;m just going to pass in the <code>constants</code> and <code>rotate_amounts</code> arrays as
globally accessibly memory. They don&rsquo;t need to be written to, and all the cores
can share them.</p>

<p>On the host side, we can pass these in:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="n">cl_mem</span> <span class="n">constantsmem</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">constantsmem</span> <span class="o">=</span> <span class="n">clCreateBuffer</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">CL_MEM_READ_ONLY</span><span class="p">,</span> <span class="mi">64</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">clEnqueueWriteBuffer</span><span class="p">(</span><span class="n">command_queue</span><span class="p">,</span> <span class="n">constantsmem</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
            <span class="mi">64</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="n">constants</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">clSetKernelArg</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cl_mem</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">constantsmem</span><span class="p">);</span>

    <span class="n">cl_mem</span> <span class="n">rotatemem</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">rotatemem</span> <span class="o">=</span> <span class="n">clCreateBuffer</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">CL_MEM_READ_ONLY</span><span class="p">,</span> <span class="mi">64</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">clEnqueueWriteBuffer</span><span class="p">(</span><span class="n">command_queue</span><span class="p">,</span> <span class="n">rotatemem</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
            <span class="mi">64</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="n">rotate_amounts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">clSetKernelArg</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cl_mem</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rotatemem</span><span class="p">);</span>
</code></pre></div>

<p>Both <code>constants</code> and <code>rotate_amounts</code> are defined elsewhere in the file in the
same way they were before as constant arrays of values.</p>

<p>I&rsquo;m going to eschew the <code>Message</code> struct thing and just inline all the padding
and such.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">acc</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x67452301</span><span class="p">,</span> <span class="mh">0xefcdab89</span><span class="p">,</span> <span class="mh">0x98badcfe</span><span class="p">,</span> <span class="mh">0x10325476</span> <span class="p">};</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">output_buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

    <span class="kt">char</span> <span class="n">input</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;abbhdwsy&quot;</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">med</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">num</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">rem</span> <span class="o">=</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">med</span><span class="p">[</span><span class="n">in</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rem</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">)</span><span class="o">?</span> <span class="p">(</span><span class="n">rem</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="sc">&#39;a&#39;</span> <span class="o">:</span> <span class="n">rem</span> <span class="o">+</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">num</span><span class="o">/</span><span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">thing</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">in</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">in</span> <span class="o">=</span> <span class="n">in</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">input</span><span class="p">[</span><span class="n">thing</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">med</span><span class="p">[</span><span class="n">in</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">orig_length_in_bytes</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">orig_length_in_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">input</span><span class="p">[</span><span class="n">orig_length_in_bytes</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="o">++</span><span class="n">orig_length_in_bytes</span><span class="p">);</span>

    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">orig_length_in_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">orig_length_in_bytes</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffffffffffff</span><span class="p">;</span>

    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">padded_length</span> <span class="o">=</span> <span class="n">orig_length_in_bytes</span><span class="p">;</span>

    <span class="n">padded_length</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">padded_length</span> <span class="o">%</span> <span class="mi">64</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">padded_length</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">orig_length_in_bytes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">output_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">output_buffer</span><span class="p">[</span><span class="n">orig_length_in_bytes</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">orig_length_in_bytes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">64</span> <span class="o">!=</span> <span class="mi">56</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">output_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
    <span class="p">}</span>

<span class="c1">// TODO: proper bit shifting here instead of this garbage &lt;&lt;&lt;</span>
    <span class="n">output_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">orig_length_in_bits</span><span class="p">;</span>
    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">64</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">output_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="c1">// TODO: proper bit shifting here instead of this garbage ^^^</span>
</code></pre></div>

<blockquote>
<p>So hey, a gentle reminder that I&rsquo;m not going to say this is the best code evah,
but it gets the job done and boy did I learn a lot.</p>
</blockquote>

<p>It&rsquo;s essentially the same as the vanilla C version, but I have to allocate
memory blocks statically with array notation instead of char pointers. And I
don&rsquo;t have library functions like <code>memcpy</code> and <code>strlen</code>, so I just do those
things manually. The <em>real</em> magic happens here though!</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="kt">char</span> <span class="n">input</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;abbhdwsy&quot;</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">med</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">num</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">rem</span> <span class="o">=</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">med</span><span class="p">[</span><span class="n">in</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rem</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">)</span><span class="o">?</span> <span class="p">(</span><span class="n">rem</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="sc">&#39;a&#39;</span> <span class="o">:</span> <span class="n">rem</span> <span class="o">+</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">num</span><span class="o">/</span><span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">intwo</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">in</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">in</span> <span class="o">=</span> <span class="n">in</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">input</span><span class="p">[</span><span class="n">intwo</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">med</span><span class="p">[</span><span class="n">in</span><span class="p">];</span>
    <span class="p">}</span>
</code></pre></div>

<p>There is my input key. And then I use
<a href="https://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/get_global_id.html"><code>get_global_id(0)</code></a>
to get a unique id number for that work item, turn that number into a string
with that first while loop, and then concatenate it onto the end of my original
input key.</p>

<p>Now, I can run this code in complete parallel over as many cores on the GPU as
I want, and each process will be running a differently numbered key!</p>

<blockquote>
<p>So, the usual shape of Open[C|G]L code is to compute values based on some 2 or
3 dimensional space. Consider a canvas- each pixel would be uniquely identified
by two coordinates. Those coordinates are available inside the kernel function
by calling <code>get_global_id</code> with <code>0</code> and <code>1</code> respectively. You&rsquo;ll pass in a 2
dimensional vecotr of values representing what you&rsquo;re trying to transform, like a photo or a frame of a video,
then address the vector by using those coordinates, and write back to an output
vector. To see this in action, try playing with
<a href="https://www.shadertoy.com/new">Shadertoy</a>, which is a really awesome little
thing to play with <a href="https://www.khronos.org/webgl/">WebGL</a>!</p>
</blockquote>

<p>Back in the host code, when I execute the kernel this time, I&rsquo;ll use
<a href="https://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clEnqueueNDRangeKernel.html">clEnqueueNDRangeKernel</a>,
which allows the code to be run across many cores in parallel!</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="cm">/* Execute OpenCL Kernel */</span>
    <span class="kt">size_t</span> <span class="n">gws</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">8000000</span> <span class="p">};</span>
    <span class="kt">size_t</span> <span class="n">lws</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span> <span class="p">};</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">clEnqueueNDRangeKernel</span><span class="p">(</span><span class="n">command_queue</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">gws</span><span class="p">,</span> <span class="n">lws</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
</code></pre></div>

<p>That first array stands for &lsquo;global work size&rsquo;, and I&rsquo;m telling it that I want
<em>one dimension</em> of global work ids that go up to 8 million. This means that
calling <code>get_global_id()</code> in the kernel functions will be numbered individually
from 0 to 8 million!</p>

<p>That&rsquo;s the magic sauce. The rest of the md5 implementation is basically the
same as before.</p>

<p>For now, I&rsquo;m going to put the test to see if it&rsquo;s a keeper hash <em>in the kernel
code</em>. If it matches, I&rsquo;ll just format and print out the complete hash:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="k">if</span> <span class="p">((</span><span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="mh">0x00000fff</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x00000fff</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%08lx%08lx%08lx%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                <span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">acc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">acc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
              <span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>

<p>If I compile and run this, Here&rsquo;s the output:</p>

<pre><code>000008bfb72caf77542c32b53a73439b
0000004ed0ede071d293b5f33de2dc2f
0000012be6057b2554c26bfddab18b08
00000bf3f1ca8d1f229aa50b3093b2be
00000512874cc40b764728993dd71ffb
0000069710beec5f9a1943a610be52d8
00000a8da36ee9b7e193f956cf701911
00000776b6ff41a7e30ed2d4b6663351
</code></pre>

<p>Oh snap, does this look familiar?</p>

<pre><code>00000 8 bfb72caf77542c32b53a73439b
00000 0 4ed0ede071d293b5f33de2dc2f
00000 1 2be6057b2554c26bfddab18b08
00000 b f3f1ca8d1f229aa50b3093b2be
00000 5 12874cc40b764728993dd71ffb
00000 6 9710beec5f9a1943a610be52d8
00000 a 8da36ee9b7e193f956cf701911
00000 7 76b6ff41a7e30ed2d4b6663351
</code></pre>

<p>Wait what? did it work? DID IT WORK? But&hellip; how long does it take??</p>

<pre><code>real    0m1.802s
</code></pre>

<p><em>Oh shit.</em> I just computed 8 million md5 hashes in <em>1.8 seconds</em>. And I am
almost sure that this is not terribly awesome OpenCL code and could probably be
attuned to go even faster than that. But 1.8 seconds is about 8 times faster
than my original solution would run, so I am pretty happy with that.</p>

<blockquote>
<p>So the TODO here is that I would like to write the chars out to a global output
buffer and then print the output to the screen from the host&rsquo;s side. Also,
there&rsquo;s a huge problem with the CL code as written here, and that is that all
the work items are running in parallel and there is no guarantee that the
output will come out &ldquo;in order.&rdquo; I have solutions to these problems but they
don&rsquo;t have anything to do with the performance gains and I am very very tired
right now. Maybe I&rsquo;ll write it up later but no promises.</p>
</blockquote>

<p><sub><a href='#toc'>toc</a></sub></p>

<div id="coda"></div>

<h1 id="advent-of-coda">Advent of Coda</h1>

<p>So, this was a major rabbit hole, but I learned a hell of a lot! I learned a
lot more about OpenCL than I was able to explain here or feel comfortable
explaining just now, but I might have more on that in the future. It&rsquo;s really
cool stuff!</p>

<p>A very cool thing / huge pain in the ass about Advent of Code is that if you
let it, almost every day can lead you down a rabbit hole like this! I just
decided to follow this one, but I traded doing the rest of the problems after
about day 9 for it. Now I have to go back and do those!</p>

<p>This was a really long post. I hope it was interesting. I&rsquo;m glad it&rsquo;s done. Have a Happy New Year!</p>

<p>Oh one more thing, <a href="https://github.com/jfo/md5">here is the source code for this,
basically</a>. No warranty.  It&rsquo;s really messy right
now and I should really have cleaned it up but #yolo and I want to go to bed.
Also if you read <em>this far</em> I hope the explanations above have been sufficient
to explain the context.</p>

                </div>
            </article>
        </div>
    </body>
</html>
