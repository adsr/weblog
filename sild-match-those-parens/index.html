<!DOCTYPE html>
<html lang="en-us">

    <head>
    <title>Sild; match those parens</title>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="icon" href="https://blog.jfo.clickimages/jeff.ico" type="image/x-icon" />
    <style type="text/css">
        @font-face {
    font-family: "etbook";
    src: url("https://blog.jfo.clickcss/et-book.woff") format('woff');
}


    </style>
    <link rel="stylesheet" href="https://blog.jfo.clickcss/style.css">
    <link rel="stylesheet" href="https://blog.jfo.clickcss/solarized-dark.css">
    <link href="" rel="alternate feed" type="application/rss+xml" title="RSS Feed for blog.jfo.click" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>


    <body>
        <div id="content">
            <header class="site-header">
    <a href="https://blog.jfo.click"><h4>archive</h4></a> &mdash;
    <a href="https://blog.jfo.clickabout"><h4>about</h4></a> &mdash;
    <a href="https://blog.jfo.clickfeed.xml"><h4>rss</h4></a>
</header>

            <article>
                <h1>Sild; match those parens</h1>
                <sub>June 16, 2016 </sub>
                <div>
                    <p>I mentioned that this isn&rsquo;t a very resilient reader right now.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="s">&quot;1 2 3&quot;</span>
</code></pre></div>

<p>Is read in as</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">LABEL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x7f91eac03a70</span><span class="p">,</span> <span class="nl">Value</span><span class="p">:</span> <span class="mi">1</span> <span class="nl">Next</span><span class="p">:</span> <span class="mh">0x7f91eac03a50</span>
<span class="n">LABEL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x7f91eac03a50</span><span class="p">,</span> <span class="nl">Value</span><span class="p">:</span> <span class="mi">2</span> <span class="nl">Next</span><span class="p">:</span> <span class="mh">0x7f91eac03a30</span>
<span class="n">LABEL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x7f91eac03a30</span><span class="p">,</span> <span class="nl">Value</span><span class="p">:</span> <span class="mi">3</span> <span class="nl">Next</span><span class="p">:</span> <span class="mh">0x10d177028</span>
<span class="n">NIL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x10d177028</span>
<span class="o">-------------------------------------------------------</span>
</code></pre></div>

<p>Which is accurate- it is just three atoms in isolation (remember, right now,
all atoms are simpy LABELs, the language doesn&rsquo;t know about any other types, so
currently a LABEL is just a string that could be any characters except for
whitespace and parens).</p>

<p>And</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="s">&quot;(1 2 3)&quot;</span>
</code></pre></div>

<p>is read as</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">LIST</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x7f9780403a90</span><span class="p">,</span> <span class="nl">List_Value</span><span class="p">:</span> <span class="mh">0x7f9780403a70</span> <span class="nl">Next</span><span class="p">:</span> <span class="mh">0x10bec2028</span>
<span class="o">|</span>   <span class="n">LABEL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x7f9780403a70</span><span class="p">,</span> <span class="nl">Value</span><span class="p">:</span> <span class="mi">1</span> <span class="nl">Next</span><span class="p">:</span> <span class="mh">0x7f9780403a50</span>
<span class="o">|</span>   <span class="n">LABEL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x7f9780403a50</span><span class="p">,</span> <span class="nl">Value</span><span class="p">:</span> <span class="mi">2</span> <span class="nl">Next</span><span class="p">:</span> <span class="mh">0x7f9780403a30</span>
<span class="o">|</span>   <span class="n">LABEL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x7f9780403a30</span><span class="p">,</span> <span class="nl">Value</span><span class="p">:</span> <span class="mi">3</span> <span class="nl">Next</span><span class="p">:</span> <span class="mh">0x10bec2028</span>
<span class="o">|</span>   <span class="n">NIL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x10bec2028</span>
<span class="o">-------------------------------------------------------</span>
<span class="n">NIL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x10bec2028</span>
<span class="o">-------------------------------------------------------</span>
</code></pre></div>

<p>Which is also correct. The final <code>NIL</code> that comes from the <code>'\0'</code> byte at the
end of the input string is a little bit offputting, but acceptable for now.</p>

<p>But what about</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="s">&quot;(1 2 3&quot;</span>
</code></pre></div>

<p>? This is <em>clearly</em> a syntax error, and yet&hellip;)</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">LIST</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x7fb983403a90</span><span class="p">,</span> <span class="nl">List_Value</span><span class="p">:</span> <span class="mh">0x7fb983403a70</span> <span class="nl">Next</span><span class="p">:</span> <span class="mh">0x10c690028</span>
<span class="o">|</span>   <span class="n">LABEL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x7fb983403a70</span><span class="p">,</span> <span class="nl">Value</span><span class="p">:</span> <span class="mi">1</span> <span class="nl">Next</span><span class="p">:</span> <span class="mh">0x7fb983403a50</span>
<span class="o">|</span>   <span class="n">LABEL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x7fb983403a50</span><span class="p">,</span> <span class="nl">Value</span><span class="p">:</span> <span class="mi">2</span> <span class="nl">Next</span><span class="p">:</span> <span class="mh">0x7fb983403a30</span>
<span class="o">|</span>   <span class="n">LABEL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x7fb983403a30</span><span class="p">,</span> <span class="nl">Value</span><span class="p">:</span> <span class="mi">3</span> <span class="nl">Next</span><span class="p">:</span> <span class="mh">0x10c690028</span>
<span class="o">|</span>   <span class="n">NIL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x10c690028</span>
<span class="o">-------------------------------------------------------</span>
<span class="n">NIL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x10c690028</span>
<span class="o">-------------------------------------------------------</span>
</code></pre></div>

<p>Harumph. At the very least this should blow up completely.</p>

<p>What about</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="s">&quot;1 2 3))))))&quot;</span>
</code></pre></div>

<p>gives</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">LABEL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x7fe913403a70</span><span class="p">,</span> <span class="nl">Value</span><span class="p">:</span> <span class="mi">1</span> <span class="nl">Next</span><span class="p">:</span> <span class="mh">0x7fe913403a50</span>
<span class="n">LABEL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x7fe913403a50</span><span class="p">,</span> <span class="nl">Value</span><span class="p">:</span> <span class="mi">2</span> <span class="nl">Next</span><span class="p">:</span> <span class="mh">0x7fe913403a30</span>
<span class="n">LABEL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x7fe913403a30</span><span class="p">,</span> <span class="nl">Value</span><span class="p">:</span> <span class="mi">3</span> <span class="nl">Next</span><span class="p">:</span> <span class="mh">0x1052df028</span>
<span class="n">NIL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x1052df028</span>
<span class="o">-------------------------------------------------------</span>
</code></pre></div>

<p>Psh.</p>

<hr>

<p>I need to guarantee somehow that the number of open and
closing parens are equal at the end of the input. A simple solution is to
create a global counter and increment it when I see an opening paren, decrement
when I see a closing paren, and check that it is <code>0</code> at the end of the string.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">int</span> <span class="n">list_depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">C</span> <span class="o">*</span> <span class="nf">read</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="o">**</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// now I have a reason to give &#39;\0&#39; its own case</span>
        <span class="k">case</span> <span class="sc">&#39;\0&#39;</span><span class="o">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">list_depth</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// this may not be very informative as of yet but it gets the jorb done</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">&amp;</span><span class="n">nil</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="k">case</span> <span class="sc">&#39;)&#39;</span><span class="o">:</span>
            <span class="n">list_depth</span><span class="o">--</span><span class="p">;</span>
            <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="n">nil</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">&#39; &#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;\n&#39;</span><span class="o">:</span>
            <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">read</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="o">:</span>
            <span class="n">list_depth</span><span class="o">++</span><span class="p">;</span>
            <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">makecell</span><span class="p">(</span><span class="n">LIST</span><span class="p">,</span> <span class="p">(</span><span class="n">V</span><span class="p">){.</span><span class="n">list</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">s</span><span class="p">)},</span> <span class="n">read</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
        <span class="k">default</span><span class="o">:</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">makecell</span><span class="p">(</span><span class="n">LABEL</span><span class="p">,</span> <span class="p">(</span><span class="n">V</span><span class="p">){</span><span class="n">read_substring</span><span class="p">(</span><span class="n">s</span><span class="p">)},</span> <span class="n">read</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>So let&rsquo;s try</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="s">&quot;(1 2 3&quot;</span>
</code></pre></div>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">shell</span> <span class="n">returned</span> <span class="mi">1</span>
</code></pre></div>

<p>OOOOOK.</p>

<p>How about&hellip;</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="s">&quot;1 2 3))))&quot;</span>
</code></pre></div>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">LABEL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x7fa219403a70</span><span class="p">,</span> <span class="nl">Value</span><span class="p">:</span> <span class="mi">1</span> <span class="nl">Next</span><span class="p">:</span> <span class="mh">0x7fa219403a50</span>
<span class="n">LABEL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x7fa219403a50</span><span class="p">,</span> <span class="nl">Value</span><span class="p">:</span> <span class="mi">2</span> <span class="nl">Next</span><span class="p">:</span> <span class="mh">0x7fa219403a30</span>
<span class="n">LABEL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x7fa219403a30</span><span class="p">,</span> <span class="nl">Value</span><span class="p">:</span> <span class="mi">3</span> <span class="nl">Next</span><span class="p">:</span> <span class="mh">0x102f17030</span>
<span class="n">NIL</span><span class="o">-</span> <span class="nl">Address</span><span class="p">:</span> <span class="mh">0x102f17030</span>
<span class="o">-------------------------------------------------------</span>
</code></pre></div>

<p>Derr, still doesn&rsquo;t work. If you look at the <code>read</code> case for <code>')'</code>, you can see
why. This reader never goes past the first closing paren, because there is not
a call to <code>read</code> inside that case to move forward! This is the intended
behavior&hellip; I&rsquo;m returning <code>&amp;nil</code> there, which is what I wanted.</p>

<p>There are two cases in which the string can be in an erroneous form.</p>

<p>1- a closing paren occurs without a preceding opening paren
2- the end of the string is reached and the <code>list_depth</code> count is <em>not</em> 0.</p>

<p>I need to verify that <em>each</em> char in the string satisfies that neither of these
conditions are met. I can pull that out into a helper function, that looks like this:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="c1">// this var still needs to be global so that read() can increment / decrement it</span>
<span class="kt">int</span> <span class="n">list_depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">verify</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;)&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">list_depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span>
            <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">list_depth</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
       <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>And now I can call it in the <code>read()</code> function:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span> <span class="nf">read</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">current_char</span> <span class="o">=</span> <span class="o">**</span><span class="n">s</span><span class="p">;</span>

    <span class="n">verify</span><span class="p">(</span><span class="n">current_char</span><span class="p">);</span>

    <span class="k">switch</span><span class="p">(</span><span class="n">current_char</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="sc">&#39;)&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;\0&#39;</span><span class="o">:</span>
            <span class="n">list_depth</span><span class="o">--</span><span class="p">;</span>
            <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="n">nil</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">&#39; &#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;\n&#39;</span><span class="o">:</span>
            <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">read</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="o">:</span>
            <span class="n">list_depth</span><span class="o">++</span><span class="p">;</span>
            <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">makecell</span><span class="p">(</span><span class="n">LIST</span><span class="p">,</span> <span class="p">(</span><span class="n">V</span><span class="p">){.</span><span class="n">list</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">s</span><span class="p">)},</span> <span class="n">read</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
        <span class="k">default</span><span class="o">:</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">makecell</span><span class="p">(</span><span class="n">LABEL</span><span class="p">,</span> <span class="p">(</span><span class="n">V</span><span class="p">){</span><span class="n">read_substring</span><span class="p">(</span><span class="n">s</span><span class="p">)},</span> <span class="n">read</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>This function has no return value, it simply exits with a generic <code>1</code> exit code
if any of these conditions exist.</p>

<hr>

<p>There is another possible error case hiding in this program.</p>

<p><code>malloc()</code> <em>can fail</em>. If it fails, say if the system isn&rsquo;t able to provide the requested memory, or whatever, it returns a <code>NULL</code> pointer. No bueno. Wherever I call <code>malloc</code>, I should also check to see that it returned a valid memory address.</p>

<p>Right now, that would be in <code>makecell()</code></p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">C</span> <span class="o">*</span><span class="nf">makecell</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">V</span> <span class="n">val</span><span class="p">,</span> <span class="n">C</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">C</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">C</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>

    <span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
    <span class="n">out</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">out</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>And in <code>read_substring()</code></p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">char</span> <span class="o">*</span><span class="nf">read_substring</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">is_not_delimiter</span><span class="p">((</span><span class="o">*</span><span class="n">s</span><span class="p">)[</span><span class="n">l</span><span class="p">]))</span> <span class="p">{</span> <span class="n">l</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">++</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">out</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>This failure case is unlikely, but it needs to be accounted for.</p>

<p>This is <em>very basic</em> error handling. I&rsquo;ve just guaranteed that in these cases
of obvious catastrophic failures- syntax errors or malloc failures, the the
program will stop running. It doesn&rsquo;t report any information to the user, it&rsquo;s
not very helpful, but it is a step in the right direction.</p>

<p>I can add at least a little bit of messaging before each exit to give some
context as to the failue. <code>fprintf()</code> can be used to write a formatted string
to an arbitrary stream, I&rsquo;ll pass in <code>stderr</code> as it is the appropriate standard
stream for messaging errors.</p>

<p>In <code>verify()</code>:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Syntax Error: mismatched parens&quot;</span><span class="p">);</span>
<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>

<p>and in <code>makecell()</code> and <code>read_substring()</code>, respectively:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;System Error: makecell failed to allocate memory.&quot;</span><span class="p">);</span>
<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;System Error: read_substring failed to allocate memory.&quot;</span><span class="p">);</span>
</code></pre></div>

<hr>

<p>Traditionally, a LISP cell is known as a <code>cons</code> cell, its value is referred to
as <code>car</code>, and its <code>next</code> member is referred to as <code>cdr</code> (pronounced &lsquo;cutter&rsquo;).
The reasons for this are <a href="https://en.wikipedia.org/wiki/CAR_and_CDR#Etymology">historical</a>:</p>

<blockquote>
<p>Lisp was originally implemented on the IBM 704 computer, in the late 1950s.
The 704 hardware had special support for splitting a 36-bit machine word into
four parts, an &ldquo;address part&rdquo; and &ldquo;decrement part&rdquo; of 15 bits each and a
&ldquo;prefix part&rdquo; and &ldquo;tag part&rdquo; of three bits each.</p>

<p>Precursors[1] [2] to Lisp included functions:</p>

<pre><code>&gt; car (short for &quot;Contents of the Address part of Register number&quot;),
&gt; cdr (&quot;Contents of the Decrement part of Register number&quot;),
&gt; cpr (&quot;Contents of the Prefix part of Register number&quot;), and
&gt; ctr (&quot;Contents of the Tag part of Register number&quot;),
&gt; ```
&gt; each of which took a machine address as an argument, loaded the corresponding
&gt; word from memory, and extracted the appropriate bits.  A machine word could
&gt; be reassembled by cons, which took four arguments (a,d,p,t).  The prefix and
&gt; tag parts were dropped in the early stages of Lisp's design, leaving CAR,
&gt; CDR, and a two-argument CONS.

I've eschewed this naming convention internally in the cell structure so far,
because I want to avoid confusion with the functions of the same names that I
will be implementing later on, but, the cell struct could easily have looked like
this.

```c
typedef struct Cons {
    enum CellType type;
    union V car;
    struct Cons * cdr;
} Cons;
</code></pre>
</blockquote>

<hr>

<p>This program now does a pretty good job of turning a parenthetical abstract
syntax tree expressed in traditional LISP syntax from a string of <code>char</code>s into
a data structure that is easy to work with inside of the program. Let&rsquo;s recap a
little bit.</p>

<ul>
<li>All data is represented as a series of cells.</li>
<li>cells have two parts, a <code>value</code> and a pointer to the <code>next</code> cell in the list
(and a type signature, but I consider that metadata!).

<ul>
<li>The value of a cell can be one of two things: an atom (currently just a
<code>LABEL</code>, represented as a string), or another <code>LIST</code> represented as a pointer
to the first cell of a sub list.

<ul>
<li>lists can be nested to arbitrary depths and end when a cell inside of
it points to <code>NIL</code> as its next value. <code>NIL</code> is a special value that
only exists in one place in memory; since all <code>NIL</code> cells are the
same, we can point to the same location to represent <code>NIL</code> anywhere.</li>
</ul></li>
</ul></li>
</ul>

                </div>
            </article>
        </div>
    </body>
</html>
